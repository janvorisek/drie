import { inject, ref, watch } from "vue";
import { Mesh, Side } from "three";
import { Color, MeshBasicMaterial } from "three";
export interface Props {
    color?: string | number;
    side?: Side;
}
declare const _sfc_main: import("vue").DefineComponent<{
    color: {
        type: (StringConstructor | NumberConstructor)[];
        required: false;
        default: number;
    };
    side: {
        type: null;
        required: false;
        default: Side;
    };
}, {
    props: any;
    mesh: Mesh<import("three").BufferGeometry, import("three").Material | import("three").Material[]>;
    three: import("vue").Ref<{
        type: string;
        color: {
            readonly isColor: true;
            r: number;
            g: number;
            b: number;
            set: (color: import("three").ColorRepresentation) => Color;
            setScalar: (scalar: number) => Color;
            setHex: (hex: number, colorSpace?: import("three").ColorSpace | undefined) => Color;
            setRGB: (r: number, g: number, b: number, colorSpace?: import("three").ColorSpace | undefined) => Color;
            setHSL: (h: number, s: number, l: number, colorSpace?: import("three").ColorSpace | undefined) => Color;
            setStyle: (style: string, colorSpace?: import("three").ColorSpace | undefined) => Color;
            setColorName: (style: string, colorSpace?: import("three").ColorSpace | undefined) => Color;
            clone: () => Color;
            copy: (color: Color) => Color;
            copySRGBToLinear: (color: Color) => Color;
            copyLinearToSRGB: (color: Color) => Color;
            convertSRGBToLinear: () => Color;
            convertLinearToSRGB: () => Color;
            getHex: (colorSpace?: import("three").ColorSpace | undefined) => number;
            getHexString: (colorSpace?: import("three").ColorSpace | undefined) => string;
            getHSL: (target: import("three").HSL, colorSpace?: import("three").ColorSpace | undefined) => import("three").HSL;
            getRGB: (target: import("three").RGB, colorSpace?: import("three").ColorSpace | undefined) => import("three").RGB;
            getStyle: (colorSpace?: import("three").ColorSpace | undefined) => string;
            offsetHSL: (h: number, s: number, l: number) => Color;
            add: (color: Color) => Color;
            addColors: (color1: Color, color2: Color) => Color;
            addScalar: (s: number) => Color;
            sub: (color: Color) => Color;
            multiply: (color: Color) => Color;
            multiplyScalar: (s: number) => Color;
            lerp: (color: Color, alpha: number) => Color;
            lerpColors: (color1: Color, color2: Color, alpha: number) => Color;
            lerpHSL: (color: Color, alpha: number) => Color;
            equals: (color: Color) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Color;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (xyz: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => Color;
            [Symbol.iterator]: () => Generator<number, void, unknown>;
        };
        map: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        lightMap: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        lightMapIntensity: number;
        aoMap: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        aoMapIntensity: number;
        specularMap: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        alphaMap: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        envMap: {
            id: number;
            uuid: string;
            name: string;
            sourceFile: string;
            source: {
                data: any;
                needsUpdate: boolean;
                uuid: string;
                version: number;
                toJSON: (meta: any) => any;
                readonly isTexture: true;
            };
            image: any;
            mipmaps: any[];
            mapping: import("three").Mapping;
            wrapS: import("three").Wrapping;
            wrapT: import("three").Wrapping;
            magFilter: import("three").TextureFilter;
            minFilter: import("three").TextureFilter;
            anisotropy: number;
            format: import("three").PixelFormat;
            internalFormat: import("three").PixelFormatGPU | null;
            type: import("three").TextureDataType;
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrixAutoUpdate: boolean;
            offset: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            repeat: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            center: {
                x: number;
                y: number;
                width: number;
                height: number;
                readonly isVector2: true;
                set: (x: number, y: number) => import("three").Vector2;
                setScalar: (scalar: number) => import("three").Vector2;
                setX: (x: number) => import("three").Vector2;
                setY: (y: number) => import("three").Vector2;
                setComponent: (index: number, value: number) => import("three").Vector2;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector2;
                copy: (v: import("three").Vector2) => import("three").Vector2;
                add: (v: import("three").Vector2, w?: import("three").Vector2 | undefined) => import("three").Vector2;
                addScalar: (s: number) => import("three").Vector2;
                addVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                addScaledVector: (v: import("three").Vector2, s: number) => import("three").Vector2;
                sub: (v: import("three").Vector2) => import("three").Vector2;
                subScalar: (s: number) => import("three").Vector2;
                subVectors: (a: import("three").Vector2, b: import("three").Vector2) => import("three").Vector2;
                multiply: (v: import("three").Vector2) => import("three").Vector2;
                multiplyScalar: (scalar: number) => import("three").Vector2;
                divide: (v: import("three").Vector2) => import("three").Vector2;
                divideScalar: (s: number) => import("three").Vector2;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector2;
                min: (v: import("three").Vector2) => import("three").Vector2;
                max: (v: import("three").Vector2) => import("three").Vector2;
                clamp: (min: import("three").Vector2, max: import("three").Vector2) => import("three").Vector2;
                clampScalar: (min: number, max: number) => import("three").Vector2;
                clampLength: (min: number, max: number) => import("three").Vector2;
                floor: () => import("three").Vector2;
                ceil: () => import("three").Vector2;
                round: () => import("three").Vector2;
                roundToZero: () => import("three").Vector2;
                negate: () => import("three").Vector2;
                dot: (v: import("three").Vector2) => number;
                cross: (v: import("three").Vector2) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                normalize: () => import("three").Vector2;
                angle: () => number;
                distanceTo: (v: import("three").Vector2) => number;
                distanceToSquared: (v: import("three").Vector2) => number;
                distanceToManhattan: (v: import("three").Vector2) => number;
                manhattanDistanceTo: (v: import("three").Vector2) => number;
                setLength: (length: number) => import("three").Vector2;
                lerp: (v: import("three").Vector2, alpha: number) => import("three").Vector2;
                lerpVectors: (v1: import("three").Vector2, v2: import("three").Vector2, alpha: number) => import("three").Vector2;
                equals: (v: import("three").Vector2) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector2;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector2Tuple | undefined, offset?: 0 | undefined): import("three").Vector2Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute, index: number) => import("three").Vector2;
                rotateAround: (center: import("three").Vector2, angle: number) => import("three").Vector2;
                random: () => import("three").Vector2;
            };
            rotation: number;
            generateMipmaps: boolean;
            premultiplyAlpha: boolean;
            flipY: boolean;
            unpackAlignment: number;
            encoding: import("three").TextureEncoding;
            isRenderTargetTexture: boolean;
            needsPMREMUpdate: boolean;
            userData: any;
            version: number;
            needsUpdate: boolean;
            readonly isTexture: true;
            onUpdate: () => void;
            clone: () => import("three").Texture;
            copy: (source: import("three").Texture) => import("three").Texture;
            toJSON: (meta: any) => any;
            dispose: () => void;
            transformUv: (uv: import("three").Vector2) => import("three").Vector2;
            updateMatrix: () => void;
            addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Texture>) => void;
            hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Texture>) => boolean;
            removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Texture>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        } | null;
        combine: import("three").Combine;
        reflectivity: number;
        refractionRatio: number;
        wireframe: boolean;
        wireframeLinewidth: number;
        wireframeLinecap: string;
        wireframeLinejoin: string;
        fog: boolean;
        setValues: (parameters: import("three").MeshBasicMaterialParameters) => void;
        alphaTest: number;
        alphaToCoverage: boolean;
        blendDst: import("three").BlendingDstFactor;
        blendDstAlpha: number | null;
        blendEquation: import("three").BlendingEquation;
        blendEquationAlpha: number | null;
        blending: import("three").Blending;
        blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
        blendSrcAlpha: number | null;
        clipIntersection: boolean;
        clippingPlanes: any;
        clipShadows: boolean;
        colorWrite: boolean;
        defines: {
            [key: string]: any;
        } | undefined;
        depthFunc: import("three").DepthModes;
        depthTest: boolean;
        depthWrite: boolean;
        id: number;
        stencilWrite: boolean;
        stencilFunc: import("three").StencilFunc;
        stencilRef: number;
        stencilWriteMask: number;
        stencilFuncMask: number;
        stencilFail: import("three").StencilOp;
        stencilZFail: import("three").StencilOp;
        stencilZPass: import("three").StencilOp;
        readonly isMaterial: true;
        name: string;
        needsUpdate: boolean;
        opacity: number;
        polygonOffset: boolean;
        polygonOffsetFactor: number;
        polygonOffsetUnits: number;
        precision: "highp" | "mediump" | "lowp" | null;
        premultipliedAlpha: boolean;
        dithering: boolean;
        side: Side;
        shadowSide: Side | null;
        toneMapped: boolean;
        transparent: boolean;
        uuid: string;
        vertexColors: boolean;
        visible: boolean;
        userData: any;
        version: number;
        clone: () => MeshBasicMaterial;
        copy: (material: import("three").Material) => MeshBasicMaterial;
        dispose: () => void;
        onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
        customProgramCacheKey: () => string;
        toJSON: (meta?: any) => any;
        addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, MeshBasicMaterial>) => void;
        hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, MeshBasicMaterial>) => boolean;
        removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, MeshBasicMaterial>) => void;
        dispatchEvent: (event: import("three").Event) => void;
    }>;
    applyProps: (props: any) => void;
    inject: typeof inject;
    ref: typeof ref;
    watch: typeof watch;
    readonly FrontSide: Side;
    readonly Mesh: typeof Mesh;
    readonly Side: typeof Side;
    readonly Color: typeof Color;
    readonly MeshBasicMaterial: typeof MeshBasicMaterial;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    color: {
        type: (StringConstructor | NumberConstructor)[];
        required: false;
        default: number;
    };
    side: {
        type: null;
        required: false;
        default: Side;
    };
}>>, {
    color: string | number;
    side: any;
}>;
export default _sfc_main;
