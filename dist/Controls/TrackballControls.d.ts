import { Camera } from "three";
import { TrackballControls } from "three/examples/jsm/controls/TrackballControls";
import { inject, ref, watch, type Ref } from "vue";
export interface Props {
    /**
     * How far you can dolly in.
     * `PerspectiveCamera` only.
     */
    minDistance?: number;
    /**
     * How far you can dolly out.
     * `PerspectiveCamera` only.
     */
    maxDistance?: number;
    /**
     * The pan speed
     */
    panSpeed?: number;
    /**
     * The rotation speed.
     */
    rotateSpeed?: number;
    /**
     * The zoom speed.
     */
    zoomSpeed?: number;
}
declare const _sfc_main: import("vue").DefineComponent<{
    minDistance: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    maxDistance: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    panSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    rotateSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    zoomSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
}, {
    props: any;
    three: Ref<{
        object: {
            matrixWorldInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            projectionMatrixInverse: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            readonly isCamera: true;
            getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
            updateMatrixWorld: (force?: boolean | undefined) => void;
            id: number;
            uuid: string;
            name: string;
            type: string;
            parent: {
                id: number;
                uuid: string;
                name: string;
                type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
                    clone: () => import("three").Quaternion;
                    copy: (q: import("three").Quaternion) => import("three").Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
                    setFromAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Quaternion;
                    setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
                    setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3) => import("three").Quaternion;
                    angleTo: (q: import("three").Quaternion) => number;
                    rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
                    identity: () => import("three").Quaternion;
                    invert: () => import("three").Quaternion;
                    conjugate: () => import("three").Quaternion;
                    dot: (v: import("three").Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import("three").Quaternion;
                    multiply: (q: import("three").Quaternion) => import("three").Quaternion;
                    premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
                    multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
                    slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                    slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                    equals: (v: import("three").Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
                    _onChange: (callback: () => void) => import("three").Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => import("three").Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: import("three").Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (channel: number) => void;
                    enable: (channel: number) => void;
                    enableAll: () => void;
                    toggle: (channel: number) => void;
                    disable: (channel: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (channel: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial: {
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                };
                customDistanceMaterial: {
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                };
                readonly isObject3D: true;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: import("three").Matrix4) => void;
                applyQuaternion: (quaternion: import("three").Quaternion) => import("three").Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: import("three").Matrix4) => void;
                setRotationFromQuaternion: (q: import("three").Quaternion) => void;
                rotateOnAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Event>;
                rotateX: (angle: number) => import("three").Object3D<import("three").Event>;
                rotateY: (angle: number) => import("three").Object3D<import("three").Event>;
                rotateZ: (angle: number) => import("three").Object3D<import("three").Event>;
                translateOnAxis: (axis: import("three").Vector3, distance: number) => import("three").Object3D<import("three").Event>;
                translateX: (distance: number) => import("three").Object3D<import("three").Event>;
                translateY: (distance: number) => import("three").Object3D<import("three").Event>;
                translateZ: (distance: number) => import("three").Object3D<import("three").Event>;
                localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
                worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
                lookAt: {
                    (vector: import("three").Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import("three").Object3D<import("three").Event>[]) => import("three").Object3D<import("three").Event>;
                remove: (...object: import("three").Object3D<import("three").Event>[]) => import("three").Object3D<import("three").Event>;
                removeFromParent: () => import("three").Object3D<import("three").Event>;
                clear: () => import("three").Object3D<import("three").Event>;
                attach: (object: import("three").Object3D<import("three").Event>) => import("three").Object3D<import("three").Event>;
                getObjectById: (id: number) => import("three").Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => import("three").Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event>[];
                getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
                getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
                getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
                getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
                raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import("three").Object3D<import("three").Event>;
                copy: (source: import("three").Object3D<import("three").Event>, recursive?: boolean | undefined) => import("three").Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, import("three").Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, import("three").Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, import("three").Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            } | null;
            children: {
                id: number;
                uuid: string;
                name: string;
                type: string;
                parent: any | null;
                children: any[];
                up: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly position: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly rotation: {
                    x: number;
                    y: number;
                    z: number;
                    order: import("three").EulerOrder;
                    readonly isEuler: true;
                    _onChangeCallback: () => void;
                    set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    clone: () => import("three").Euler;
                    copy: (euler: import("three").Euler) => import("three").Euler;
                    setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                    setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                    reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                    equals: (euler: import("three").Euler) => boolean;
                    fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                    toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                    _onChange: (callback: () => void) => import("three").Euler;
                    [Symbol.iterator]: () => Generator<string | number, void, unknown>;
                };
                readonly quaternion: {
                    x: number;
                    y: number;
                    z: number;
                    w: number;
                    readonly isQuaternion: true;
                    set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
                    clone: () => import("three").Quaternion;
                    copy: (q: import("three").Quaternion) => import("three").Quaternion;
                    setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
                    setFromAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Quaternion;
                    setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
                    setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3) => import("three").Quaternion;
                    angleTo: (q: import("three").Quaternion) => number;
                    rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
                    identity: () => import("three").Quaternion;
                    invert: () => import("three").Quaternion;
                    conjugate: () => import("three").Quaternion;
                    dot: (v: import("three").Quaternion) => number;
                    lengthSq: () => number;
                    length: () => number;
                    normalize: () => import("three").Quaternion;
                    multiply: (q: import("three").Quaternion) => import("three").Quaternion;
                    premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
                    multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
                    slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                    slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                    equals: (v: import("three").Quaternion) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
                    _onChange: (callback: () => void) => import("three").Quaternion;
                    _onChangeCallback: () => void;
                    multiplyVector3: (v: any) => any;
                    random: () => import("three").Quaternion;
                    [Symbol.iterator]: () => Generator<number, void, unknown>;
                };
                readonly scale: {
                    x: number;
                    y: number;
                    z: number;
                    readonly isVector3: true;
                    set: (x: number, y: number, z: number) => import("three").Vector3;
                    setScalar: (scalar: number) => import("three").Vector3;
                    setX: (x: number) => import("three").Vector3;
                    setY: (y: number) => import("three").Vector3;
                    setZ: (z: number) => import("three").Vector3;
                    setComponent: (index: number, value: number) => import("three").Vector3;
                    getComponent: (index: number) => number;
                    clone: () => import("three").Vector3;
                    copy: (v: import("three").Vector3) => import("three").Vector3;
                    add: (v: import("three").Vector3) => import("three").Vector3;
                    addScalar: (s: number) => import("three").Vector3;
                    addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                    addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    sub: (a: import("three").Vector3) => import("three").Vector3;
                    subScalar: (s: number) => import("three").Vector3;
                    subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    multiply: (v: import("three").Vector3) => import("three").Vector3;
                    multiplyScalar: (s: number) => import("three").Vector3;
                    multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                    applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                    applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                    applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                    applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                    applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                    project: (camera: Camera) => import("three").Vector3;
                    unproject: (camera: Camera) => import("three").Vector3;
                    transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                    divide: (v: import("three").Vector3) => import("three").Vector3;
                    divideScalar: (s: number) => import("three").Vector3;
                    min: (v: import("three").Vector3) => import("three").Vector3;
                    max: (v: import("three").Vector3) => import("three").Vector3;
                    clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                    clampScalar: (min: number, max: number) => import("three").Vector3;
                    clampLength: (min: number, max: number) => import("three").Vector3;
                    floor: () => import("three").Vector3;
                    ceil: () => import("three").Vector3;
                    round: () => import("three").Vector3;
                    roundToZero: () => import("three").Vector3;
                    negate: () => import("three").Vector3;
                    dot: (v: import("three").Vector3) => number;
                    lengthSq: () => number;
                    length: () => number;
                    lengthManhattan: () => number;
                    manhattanLength: () => number;
                    manhattanDistanceTo: (v: import("three").Vector3) => number;
                    normalize: () => import("three").Vector3;
                    setLength: (l: number) => import("three").Vector3;
                    lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                    lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                    cross: (a: import("three").Vector3) => import("three").Vector3;
                    crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                    projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                    projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                    reflect: (vector: import("three").Vector3) => import("three").Vector3;
                    angleTo: (v: import("three").Vector3) => number;
                    distanceTo: (v: import("three").Vector3) => number;
                    distanceToSquared: (v: import("three").Vector3) => number;
                    distanceToManhattan: (v: import("three").Vector3) => number;
                    setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                    setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                    setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                    setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                    setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                    setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                    setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                    setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                    equals: (v: import("three").Vector3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                        (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                    };
                    fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                    random: () => import("three").Vector3;
                    randomDirection: () => import("three").Vector3;
                };
                readonly modelViewMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                readonly normalMatrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                    identity: () => import("three").Matrix3;
                    clone: () => import("three").Matrix3;
                    copy: (m: import("three").Matrix3) => import("three").Matrix3;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                    setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                    multiplyScalar: (s: number) => import("three").Matrix3;
                    determinant: () => number;
                    invert: () => import("three").Matrix3;
                    transpose: () => import("three").Matrix3;
                    getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                    transposeIntoArray: (r: number[]) => import("three").Matrix3;
                    setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                    scale: (sx: number, sy: number) => import("three").Matrix3;
                    makeTranslation: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    makeRotation: {
                        (theta: number): import("three").Matrix3;
                        (theta: number): import("three").Matrix3;
                    };
                    makeScale: {
                        (x: number, y: number): import("three").Matrix3;
                        (x: number, y: number): import("three").Matrix3;
                    };
                    rotate: (theta: number) => import("three").Matrix3;
                    translate: (tx: number, ty: number) => import("three").Matrix3;
                    equals: (matrix: import("three").Matrix3) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                    multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                    multiplyVector3: (vector: import("three").Vector3) => any;
                    multiplyVector3Array: (a: any) => any;
                    getInverse: {
                        (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                        (matrix: import("three").Matrix): import("three").Matrix;
                    };
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                };
                matrix: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixWorld: {
                    elements: number[];
                    set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                    identity: () => import("three").Matrix4;
                    clone: () => import("three").Matrix4;
                    copy: (m: import("three").Matrix4) => import("three").Matrix4;
                    copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                    extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                    makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                    makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                    multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                    multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                    multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                    multiplyScalar: (s: number) => import("three").Matrix4;
                    determinant: () => number;
                    transpose: () => import("three").Matrix4;
                    setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                    invert: () => import("three").Matrix4;
                    scale: (v: import("three").Vector3) => import("three").Matrix4;
                    getMaxScaleOnAxis: () => number;
                    makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeRotationX: (theta: number) => import("three").Matrix4;
                    makeRotationY: (theta: number) => import("three").Matrix4;
                    makeRotationZ: (theta: number) => import("three").Matrix4;
                    makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                    makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                    makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                    compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                    makePerspective: {
                        (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                        (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                    };
                    makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                    equals: (matrix: import("three").Matrix4) => boolean;
                    fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                    toArray: {
                        (array?: number[] | undefined, offset?: number | undefined): number[];
                        (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                        (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                    };
                    setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                    extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                    setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                    multiplyVector3: (v: any) => any;
                    multiplyVector4: (v: any) => any;
                    multiplyVector3Array: (array: number[]) => number[];
                    rotateAxis: (v: any) => void;
                    crossVector: (v: any) => void;
                    flattenToArrayOffset: (array: number[], offset: number) => number[];
                    getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
                };
                matrixAutoUpdate: boolean;
                matrixWorldAutoUpdate: boolean;
                matrixWorldNeedsUpdate: boolean;
                layers: {
                    mask: number;
                    set: (channel: number) => void;
                    enable: (channel: number) => void;
                    enableAll: () => void;
                    toggle: (channel: number) => void;
                    disable: (channel: number) => void;
                    disableAll: () => void;
                    test: (layers: import("three").Layers) => boolean;
                    isEnabled: (channel: number) => boolean;
                };
                visible: boolean;
                castShadow: boolean;
                receiveShadow: boolean;
                frustumCulled: boolean;
                renderOrder: number;
                animations: {
                    name: string;
                    tracks: {
                        name: string;
                        times: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        values: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueTypeName: string;
                        TimeBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        ValueBufferType: {
                            [x: number]: number;
                            readonly BYTES_PER_ELEMENT: number;
                            readonly buffer: {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                                readonly [Symbol.toStringTag]: string;
                            } | {
                                readonly byteLength: number;
                                slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                                readonly [Symbol.species]: SharedArrayBuffer;
                                readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                            };
                            readonly byteLength: number;
                            readonly byteOffset: number;
                            copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                            every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                            filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                            find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                            findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                            forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                            indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            join: (separator?: string | undefined) => string;
                            lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                            readonly length: number;
                            map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                            reduce: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                            };
                            reduceRight: {
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                                (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                                <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                            };
                            reverse: () => Float32Array;
                            set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                            slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                            some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                            sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                            subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                            toLocaleString: () => string;
                            toString: () => string;
                            valueOf: () => Float32Array;
                            entries: () => IterableIterator<[number, number]>;
                            keys: () => IterableIterator<number>;
                            values: () => IterableIterator<number>;
                            includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                            at: (index: number) => number | undefined;
                            [Symbol.iterator]: () => IterableIterator<number>;
                            readonly [Symbol.toStringTag]: "Float32Array";
                        };
                        DefaultInterpolation: import("three").InterpolationModes;
                        InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                        InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                        InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                        setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                        getInterpolation: () => import("three").InterpolationModes;
                        createInterpolant: () => import("three").Interpolant;
                        getValueSize: () => number;
                        shift: (timeOffset: number) => import("three").KeyframeTrack;
                        scale: (timeScale: number) => import("three").KeyframeTrack;
                        trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                        validate: () => boolean;
                        optimize: () => import("three").KeyframeTrack;
                        clone: () => import("three").KeyframeTrack;
                    }[];
                    blendMode: import("three").AnimationBlendMode;
                    duration: number;
                    uuid: string;
                    results: any[];
                    resetDuration: () => import("three").AnimationClip;
                    trim: () => import("three").AnimationClip;
                    validate: () => boolean;
                    optimize: () => import("three").AnimationClip;
                    clone: () => import("three").AnimationClip;
                    toJSON: (clip: import("three").AnimationClip) => any;
                }[];
                userData: {
                    [key: string]: any;
                };
                customDepthMaterial: {
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                };
                customDistanceMaterial: {
                    alphaTest: number;
                    alphaToCoverage: boolean;
                    blendDst: import("three").BlendingDstFactor;
                    blendDstAlpha: number | null;
                    blendEquation: import("three").BlendingEquation;
                    blendEquationAlpha: number | null;
                    blending: import("three").Blending;
                    blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                    blendSrcAlpha: number | null;
                    clipIntersection: boolean;
                    clippingPlanes: any;
                    clipShadows: boolean;
                    colorWrite: boolean;
                    defines: {
                        [key: string]: any;
                    } | undefined;
                    depthFunc: import("three").DepthModes;
                    depthTest: boolean;
                    depthWrite: boolean;
                    id: number;
                    stencilWrite: boolean;
                    stencilFunc: import("three").StencilFunc;
                    stencilRef: number;
                    stencilWriteMask: number;
                    stencilFuncMask: number;
                    stencilFail: import("three").StencilOp;
                    stencilZFail: import("three").StencilOp;
                    stencilZPass: import("three").StencilOp;
                    readonly isMaterial: true;
                    name: string;
                    needsUpdate: boolean;
                    opacity: number;
                    polygonOffset: boolean;
                    polygonOffsetFactor: number;
                    polygonOffsetUnits: number;
                    precision: "highp" | "mediump" | "lowp" | null;
                    premultipliedAlpha: boolean;
                    forceSinglePass: boolean;
                    dithering: boolean;
                    side: import("three").Side;
                    shadowSide: import("three").Side | null;
                    toneMapped: boolean;
                    transparent: boolean;
                    type: string;
                    uuid: string;
                    vertexColors: boolean;
                    visible: boolean;
                    userData: any;
                    version: number;
                    clone: () => import("three").Material;
                    copy: (material: import("three").Material) => import("three").Material;
                    dispose: () => void;
                    onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                    customProgramCacheKey: () => string;
                    setValues: (values: import("three").MaterialParameters) => void;
                    toJSON: (meta?: any) => any;
                    addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                    hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                    removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                    dispatchEvent: (event: import("three").Event) => void;
                };
                readonly isObject3D: true;
                onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
                onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
                applyMatrix4: (matrix: import("three").Matrix4) => void;
                applyQuaternion: (quaternion: import("three").Quaternion) => import("three").Object3D<import("three").Event>;
                setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
                setRotationFromEuler: (euler: import("three").Euler) => void;
                setRotationFromMatrix: (m: import("three").Matrix4) => void;
                setRotationFromQuaternion: (q: import("three").Quaternion) => void;
                rotateOnAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Event>;
                rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => import("three").Object3D<import("three").Event>;
                rotateX: (angle: number) => import("three").Object3D<import("three").Event>;
                rotateY: (angle: number) => import("three").Object3D<import("three").Event>;
                rotateZ: (angle: number) => import("three").Object3D<import("three").Event>;
                translateOnAxis: (axis: import("three").Vector3, distance: number) => import("three").Object3D<import("three").Event>;
                translateX: (distance: number) => import("three").Object3D<import("three").Event>;
                translateY: (distance: number) => import("three").Object3D<import("three").Event>;
                translateZ: (distance: number) => import("three").Object3D<import("three").Event>;
                localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
                worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
                lookAt: {
                    (vector: import("three").Vector3): void;
                    (x: number, y: number, z: number): void;
                };
                add: (...object: import("three").Object3D<import("three").Event>[]) => import("three").Object3D<import("three").Event>;
                remove: (...object: import("three").Object3D<import("three").Event>[]) => import("three").Object3D<import("three").Event>;
                removeFromParent: () => import("three").Object3D<import("three").Event>;
                clear: () => import("three").Object3D<import("three").Event>;
                attach: (object: import("three").Object3D<import("three").Event>) => import("three").Object3D<import("three").Event>;
                getObjectById: (id: number) => import("three").Object3D<import("three").Event> | undefined;
                getObjectByName: (name: string) => import("three").Object3D<import("three").Event> | undefined;
                getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event> | undefined;
                getObjectsByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event>[];
                getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
                getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
                getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
                getWorldDirection: (target: import("three").Vector3) => import("three").Vector3;
                raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Event>>[]) => void;
                traverse: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                traverseVisible: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                traverseAncestors: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
                updateMatrix: () => void;
                updateMatrixWorld: (force?: boolean | undefined) => void;
                updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
                toJSON: (meta?: {
                    geometries: any;
                    materials: any;
                    textures: any;
                    images: any;
                } | undefined) => any;
                clone: (recursive?: boolean | undefined) => import("three").Object3D<import("three").Event>;
                copy: (source: import("three").Object3D<import("three").Event>, recursive?: boolean | undefined) => import("three").Object3D<import("three").Event>;
                addEventListener: <T_3 extends string>(type: T_3, listener: import("three").EventListener<import("three").Event, T_3, import("three").Object3D<import("three").Event>>) => void;
                hasEventListener: <T_4 extends string>(type: T_4, listener: import("three").EventListener<import("three").Event, T_4, import("three").Object3D<import("three").Event>>) => boolean;
                removeEventListener: <T_5 extends string>(type: T_5, listener: import("three").EventListener<import("three").Event, T_5, import("three").Object3D<import("three").Event>>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            }[];
            up: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import("three").Vector3;
                setScalar: (scalar: number) => import("three").Vector3;
                setX: (x: number) => import("three").Vector3;
                setY: (y: number) => import("three").Vector3;
                setZ: (z: number) => import("three").Vector3;
                setComponent: (index: number, value: number) => import("three").Vector3;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector3;
                copy: (v: import("three").Vector3) => import("three").Vector3;
                add: (v: import("three").Vector3) => import("three").Vector3;
                addScalar: (s: number) => import("three").Vector3;
                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                sub: (a: import("three").Vector3) => import("three").Vector3;
                subScalar: (s: number) => import("three").Vector3;
                subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                multiply: (v: import("three").Vector3) => import("three").Vector3;
                multiplyScalar: (s: number) => import("three").Vector3;
                multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                project: (camera: Camera) => import("three").Vector3;
                unproject: (camera: Camera) => import("three").Vector3;
                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                divide: (v: import("three").Vector3) => import("three").Vector3;
                divideScalar: (s: number) => import("three").Vector3;
                min: (v: import("three").Vector3) => import("three").Vector3;
                max: (v: import("three").Vector3) => import("three").Vector3;
                clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                clampScalar: (min: number, max: number) => import("three").Vector3;
                clampLength: (min: number, max: number) => import("three").Vector3;
                floor: () => import("three").Vector3;
                ceil: () => import("three").Vector3;
                round: () => import("three").Vector3;
                roundToZero: () => import("three").Vector3;
                negate: () => import("three").Vector3;
                dot: (v: import("three").Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: import("three").Vector3) => number;
                normalize: () => import("three").Vector3;
                setLength: (l: number) => import("three").Vector3;
                lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                cross: (a: import("three").Vector3) => import("three").Vector3;
                crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                reflect: (vector: import("three").Vector3) => import("three").Vector3;
                angleTo: (v: import("three").Vector3) => number;
                distanceTo: (v: import("three").Vector3) => number;
                distanceToSquared: (v: import("three").Vector3) => number;
                distanceToManhattan: (v: import("three").Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                equals: (v: import("three").Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                random: () => import("three").Vector3;
                randomDirection: () => import("three").Vector3;
            };
            readonly position: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import("three").Vector3;
                setScalar: (scalar: number) => import("three").Vector3;
                setX: (x: number) => import("three").Vector3;
                setY: (y: number) => import("three").Vector3;
                setZ: (z: number) => import("three").Vector3;
                setComponent: (index: number, value: number) => import("three").Vector3;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector3;
                copy: (v: import("three").Vector3) => import("three").Vector3;
                add: (v: import("three").Vector3) => import("three").Vector3;
                addScalar: (s: number) => import("three").Vector3;
                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                sub: (a: import("three").Vector3) => import("three").Vector3;
                subScalar: (s: number) => import("three").Vector3;
                subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                multiply: (v: import("three").Vector3) => import("three").Vector3;
                multiplyScalar: (s: number) => import("three").Vector3;
                multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                project: (camera: Camera) => import("three").Vector3;
                unproject: (camera: Camera) => import("three").Vector3;
                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                divide: (v: import("three").Vector3) => import("three").Vector3;
                divideScalar: (s: number) => import("three").Vector3;
                min: (v: import("three").Vector3) => import("three").Vector3;
                max: (v: import("three").Vector3) => import("three").Vector3;
                clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                clampScalar: (min: number, max: number) => import("three").Vector3;
                clampLength: (min: number, max: number) => import("three").Vector3;
                floor: () => import("three").Vector3;
                ceil: () => import("three").Vector3;
                round: () => import("three").Vector3;
                roundToZero: () => import("three").Vector3;
                negate: () => import("three").Vector3;
                dot: (v: import("three").Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: import("three").Vector3) => number;
                normalize: () => import("three").Vector3;
                setLength: (l: number) => import("three").Vector3;
                lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                cross: (a: import("three").Vector3) => import("three").Vector3;
                crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                reflect: (vector: import("three").Vector3) => import("three").Vector3;
                angleTo: (v: import("three").Vector3) => number;
                distanceTo: (v: import("three").Vector3) => number;
                distanceToSquared: (v: import("three").Vector3) => number;
                distanceToManhattan: (v: import("three").Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                equals: (v: import("three").Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                random: () => import("three").Vector3;
                randomDirection: () => import("three").Vector3;
            };
            readonly rotation: {
                x: number;
                y: number;
                z: number;
                order: import("three").EulerOrder;
                readonly isEuler: true;
                _onChangeCallback: () => void;
                set: (x: number, y: number, z: number, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                clone: () => import("three").Euler;
                copy: (euler: import("three").Euler) => import("three").Euler;
                setFromRotationMatrix: (m: import("three").Matrix4, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromQuaternion: (q: import("three").Quaternion, order?: import("three").EulerOrder | undefined, update?: boolean | undefined) => import("three").Euler;
                setFromVector3: (v: import("three").Vector3, order?: import("three").EulerOrder | undefined) => import("three").Euler;
                reorder: (newOrder: import("three").EulerOrder) => import("three").Euler;
                equals: (euler: import("three").Euler) => boolean;
                fromArray: (xyzo: [number, number, number, (import("three").EulerOrder | undefined)?, ...any[]]) => import("three").Euler;
                toArray: (array?: (string | number | undefined)[] | undefined, offset?: number | undefined) => (string | number | undefined)[];
                _onChange: (callback: () => void) => import("three").Euler;
                [Symbol.iterator]: () => Generator<string | number, void, unknown>;
            };
            readonly quaternion: {
                x: number;
                y: number;
                z: number;
                w: number;
                readonly isQuaternion: true;
                set: (x: number, y: number, z: number, w: number) => import("three").Quaternion;
                clone: () => import("three").Quaternion;
                copy: (q: import("three").Quaternion) => import("three").Quaternion;
                setFromEuler: (euler: import("three").Euler, update?: boolean | undefined) => import("three").Quaternion;
                setFromAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Quaternion;
                setFromRotationMatrix: (m: import("three").Matrix4) => import("three").Quaternion;
                setFromUnitVectors: (vFrom: import("three").Vector3, vTo: import("three").Vector3) => import("three").Quaternion;
                angleTo: (q: import("three").Quaternion) => number;
                rotateTowards: (q: import("three").Quaternion, step: number) => import("three").Quaternion;
                identity: () => import("three").Quaternion;
                invert: () => import("three").Quaternion;
                conjugate: () => import("three").Quaternion;
                dot: (v: import("three").Quaternion) => number;
                lengthSq: () => number;
                length: () => number;
                normalize: () => import("three").Quaternion;
                multiply: (q: import("three").Quaternion) => import("three").Quaternion;
                premultiply: (q: import("three").Quaternion) => import("three").Quaternion;
                multiplyQuaternions: (a: import("three").Quaternion, b: import("three").Quaternion) => import("three").Quaternion;
                slerp: (qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                slerpQuaternions: (qa: import("three").Quaternion, qb: import("three").Quaternion, t: number) => import("three").Quaternion;
                equals: (v: import("three").Quaternion) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Quaternion;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Quaternion;
                _onChange: (callback: () => void) => import("three").Quaternion;
                _onChangeCallback: () => void;
                multiplyVector3: (v: any) => any;
                random: () => import("three").Quaternion;
                [Symbol.iterator]: () => Generator<number, void, unknown>;
            };
            readonly scale: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => import("three").Vector3;
                setScalar: (scalar: number) => import("three").Vector3;
                setX: (x: number) => import("three").Vector3;
                setY: (y: number) => import("three").Vector3;
                setZ: (z: number) => import("three").Vector3;
                setComponent: (index: number, value: number) => import("three").Vector3;
                getComponent: (index: number) => number;
                clone: () => import("three").Vector3;
                copy: (v: import("three").Vector3) => import("three").Vector3;
                add: (v: import("three").Vector3) => import("three").Vector3;
                addScalar: (s: number) => import("three").Vector3;
                addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
                addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                sub: (a: import("three").Vector3) => import("three").Vector3;
                subScalar: (s: number) => import("three").Vector3;
                subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                multiply: (v: import("three").Vector3) => import("three").Vector3;
                multiplyScalar: (s: number) => import("three").Vector3;
                multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                applyEuler: (euler: import("three").Euler) => import("three").Vector3;
                applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
                applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
                applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
                applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
                project: (camera: Camera) => import("three").Vector3;
                unproject: (camera: Camera) => import("three").Vector3;
                transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
                divide: (v: import("three").Vector3) => import("three").Vector3;
                divideScalar: (s: number) => import("three").Vector3;
                min: (v: import("three").Vector3) => import("three").Vector3;
                max: (v: import("three").Vector3) => import("three").Vector3;
                clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
                clampScalar: (min: number, max: number) => import("three").Vector3;
                clampLength: (min: number, max: number) => import("three").Vector3;
                floor: () => import("three").Vector3;
                ceil: () => import("three").Vector3;
                round: () => import("three").Vector3;
                roundToZero: () => import("three").Vector3;
                negate: () => import("three").Vector3;
                dot: (v: import("three").Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: import("three").Vector3) => number;
                normalize: () => import("three").Vector3;
                setLength: (l: number) => import("three").Vector3;
                lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
                lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
                cross: (a: import("three").Vector3) => import("three").Vector3;
                crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
                projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
                projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
                reflect: (vector: import("three").Vector3) => import("three").Vector3;
                angleTo: (v: import("three").Vector3) => number;
                distanceTo: (v: import("three").Vector3) => number;
                distanceToSquared: (v: import("three").Vector3) => number;
                distanceToManhattan: (v: import("three").Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
                setFromEuler: (e: import("three").Euler) => import("three").Vector3;
                equals: (v: import("three").Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
                random: () => import("three").Vector3;
                randomDirection: () => import("three").Vector3;
            };
            readonly modelViewMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            readonly normalMatrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n21: number, n22: number, n23: number, n31: number, n32: number, n33: number) => import("three").Matrix3;
                identity: () => import("three").Matrix3;
                clone: () => import("three").Matrix3;
                copy: (m: import("three").Matrix3) => import("three").Matrix3;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix3;
                setFromMatrix4: (m: import("three").Matrix4) => import("three").Matrix3;
                multiplyScalar: (s: number) => import("three").Matrix3;
                determinant: () => number;
                invert: () => import("three").Matrix3;
                transpose: () => import("three").Matrix3;
                getNormalMatrix: (matrix4: import("three").Matrix4) => import("three").Matrix3;
                transposeIntoArray: (r: number[]) => import("three").Matrix3;
                setUvTransform: (tx: number, ty: number, sx: number, sy: number, rotation: number, cx: number, cy: number) => import("three").Matrix3;
                scale: (sx: number, sy: number) => import("three").Matrix3;
                makeTranslation: {
                    (x: number, y: number): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                makeRotation: {
                    (theta: number): import("three").Matrix3;
                    (theta: number): import("three").Matrix3;
                };
                makeScale: {
                    (x: number, y: number): import("three").Matrix3;
                    (x: number, y: number): import("three").Matrix3;
                };
                rotate: (theta: number) => import("three").Matrix3;
                translate: (tx: number, ty: number) => import("three").Matrix3;
                equals: (matrix: import("three").Matrix3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix3Tuple | undefined, offset?: 0 | undefined): import("three").Matrix3Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                multiply: (m: import("three").Matrix3) => import("three").Matrix3;
                premultiply: (m: import("three").Matrix3) => import("three").Matrix3;
                multiplyMatrices: (a: import("three").Matrix3, b: import("three").Matrix3) => import("three").Matrix3;
                multiplyVector3: (vector: import("three").Vector3) => any;
                multiplyVector3Array: (a: any) => any;
                getInverse: {
                    (matrix: import("three").Matrix4, throwOnDegenerate?: boolean | undefined): import("three").Matrix3;
                    (matrix: import("three").Matrix): import("three").Matrix;
                };
                flattenToArrayOffset: (array: number[], offset: number) => number[];
            };
            matrix: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixWorld: {
                elements: number[];
                set: (n11: number, n12: number, n13: number, n14: number, n21: number, n22: number, n23: number, n24: number, n31: number, n32: number, n33: number, n34: number, n41: number, n42: number, n43: number, n44: number) => import("three").Matrix4;
                identity: () => import("three").Matrix4;
                clone: () => import("three").Matrix4;
                copy: (m: import("three").Matrix4) => import("three").Matrix4;
                copyPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                extractBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                makeBasis: (xAxis: import("three").Vector3, yAxis: import("three").Vector3, zAxis: import("three").Vector3) => import("three").Matrix4;
                extractRotation: (m: import("three").Matrix4) => import("three").Matrix4;
                makeRotationFromEuler: (euler: import("three").Euler) => import("three").Matrix4;
                makeRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                lookAt: (eye: import("three").Vector3, target: import("three").Vector3, up: import("three").Vector3) => import("three").Matrix4;
                multiply: (m: import("three").Matrix4) => import("three").Matrix4;
                premultiply: (m: import("three").Matrix4) => import("three").Matrix4;
                multiplyMatrices: (a: import("three").Matrix4, b: import("three").Matrix4) => import("three").Matrix4;
                multiplyToArray: (a: import("three").Matrix4, b: import("three").Matrix4, r: number[]) => import("three").Matrix4;
                multiplyScalar: (s: number) => import("three").Matrix4;
                determinant: () => number;
                transpose: () => import("three").Matrix4;
                setPosition: (v: number | import("three").Vector3, y?: number | undefined, z?: number | undefined) => import("three").Matrix4;
                invert: () => import("three").Matrix4;
                scale: (v: import("three").Vector3) => import("three").Matrix4;
                getMaxScaleOnAxis: () => number;
                makeTranslation: (x: number, y: number, z: number) => import("three").Matrix4;
                makeRotationX: (theta: number) => import("three").Matrix4;
                makeRotationY: (theta: number) => import("three").Matrix4;
                makeRotationZ: (theta: number) => import("three").Matrix4;
                makeRotationAxis: (axis: import("three").Vector3, angle: number) => import("three").Matrix4;
                makeScale: (x: number, y: number, z: number) => import("three").Matrix4;
                makeShear: (xy: number, xz: number, yx: number, yz: number, zx: number, zy: number) => import("three").Matrix4;
                compose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                decompose: (translation: import("three").Vector3, rotation: import("three").Quaternion, scale: import("three").Vector3) => import("three").Matrix4;
                makePerspective: {
                    (left: number, right: number, bottom: number, top: number, near: number, far: number): import("three").Matrix4;
                    (fov: number, aspect: number, near: number, far: number): import("three").Matrix4;
                };
                makeOrthographic: (left: number, right: number, top: number, bottom: number, near: number, far: number) => import("three").Matrix4;
                equals: (matrix: import("three").Matrix4) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Matrix4;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Matrix4Tuple | undefined, offset?: 0 | undefined): import("three").Matrix4Tuple;
                    (array?: ArrayLike<number> | undefined, offset?: number | undefined): ArrayLike<number>;
                };
                setFromMatrix3: (m: import("three").Matrix3) => import("three").Matrix4;
                extractPosition: (m: import("three").Matrix4) => import("three").Matrix4;
                setRotationFromQuaternion: (q: import("three").Quaternion) => import("three").Matrix4;
                multiplyVector3: (v: any) => any;
                multiplyVector4: (v: any) => any;
                multiplyVector3Array: (array: number[]) => number[];
                rotateAxis: (v: any) => void;
                crossVector: (v: any) => void;
                flattenToArrayOffset: (array: number[], offset: number) => number[];
                getInverse: (matrix: import("three").Matrix) => import("three").Matrix;
            };
            matrixAutoUpdate: boolean;
            matrixWorldAutoUpdate: boolean;
            matrixWorldNeedsUpdate: boolean;
            layers: {
                mask: number;
                set: (channel: number) => void;
                enable: (channel: number) => void;
                enableAll: () => void;
                toggle: (channel: number) => void;
                disable: (channel: number) => void;
                disableAll: () => void;
                test: (layers: import("three").Layers) => boolean;
                isEnabled: (channel: number) => boolean;
            };
            visible: boolean;
            castShadow: boolean;
            receiveShadow: boolean;
            frustumCulled: boolean;
            renderOrder: number;
            animations: {
                name: string;
                tracks: {
                    name: string;
                    times: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    values: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueTypeName: string;
                    TimeBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    ValueBufferType: {
                        [x: number]: number;
                        readonly BYTES_PER_ELEMENT: number;
                        readonly buffer: {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => ArrayBuffer;
                            readonly [Symbol.toStringTag]: string;
                        } | {
                            readonly byteLength: number;
                            slice: (begin: number, end?: number | undefined) => SharedArrayBuffer;
                            readonly [Symbol.species]: SharedArrayBuffer;
                            readonly [Symbol.toStringTag]: "SharedArrayBuffer";
                        };
                        readonly byteLength: number;
                        readonly byteOffset: number;
                        copyWithin: (target: number, start: number, end?: number | undefined) => Float32Array;
                        every: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        fill: (value: number, start?: number | undefined, end?: number | undefined) => Float32Array;
                        filter: (predicate: (value: number, index: number, array: Float32Array) => any, thisArg?: any) => Float32Array;
                        find: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number | undefined;
                        findIndex: (predicate: (value: number, index: number, obj: Float32Array) => boolean, thisArg?: any) => number;
                        forEach: (callbackfn: (value: number, index: number, array: Float32Array) => void, thisArg?: any) => void;
                        indexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        join: (separator?: string | undefined) => string;
                        lastIndexOf: (searchElement: number, fromIndex?: number | undefined) => number;
                        readonly length: number;
                        map: (callbackfn: (value: number, index: number, array: Float32Array) => number, thisArg?: any) => Float32Array;
                        reduce: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U>(callbackfn: (previousValue: U, currentValue: number, currentIndex: number, array: Float32Array) => U, initialValue: U): U;
                        };
                        reduceRight: {
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number): number;
                            (callbackfn: (previousValue: number, currentValue: number, currentIndex: number, array: Float32Array) => number, initialValue: number): number;
                            <U_1>(callbackfn: (previousValue: U_1, currentValue: number, currentIndex: number, array: Float32Array) => U_1, initialValue: U_1): U_1;
                        };
                        reverse: () => Float32Array;
                        set: (array: ArrayLike<number>, offset?: number | undefined) => void;
                        slice: (start?: number | undefined, end?: number | undefined) => Float32Array;
                        some: (predicate: (value: number, index: number, array: Float32Array) => unknown, thisArg?: any) => boolean;
                        sort: (compareFn?: ((a: number, b: number) => number) | undefined) => Float32Array;
                        subarray: (begin?: number | undefined, end?: number | undefined) => Float32Array;
                        toLocaleString: () => string;
                        toString: () => string;
                        valueOf: () => Float32Array;
                        entries: () => IterableIterator<[number, number]>;
                        keys: () => IterableIterator<number>;
                        values: () => IterableIterator<number>;
                        includes: (searchElement: number, fromIndex?: number | undefined) => boolean;
                        at: (index: number) => number | undefined;
                        [Symbol.iterator]: () => IterableIterator<number>;
                        readonly [Symbol.toStringTag]: "Float32Array";
                    };
                    DefaultInterpolation: import("three").InterpolationModes;
                    InterpolantFactoryMethodDiscrete: (result: any) => import("three").DiscreteInterpolant;
                    InterpolantFactoryMethodLinear: (result: any) => import("three").LinearInterpolant;
                    InterpolantFactoryMethodSmooth: (result: any) => import("three").CubicInterpolant;
                    setInterpolation: (interpolation: import("three").InterpolationModes) => import("three").KeyframeTrack;
                    getInterpolation: () => import("three").InterpolationModes;
                    createInterpolant: () => import("three").Interpolant;
                    getValueSize: () => number;
                    shift: (timeOffset: number) => import("three").KeyframeTrack;
                    scale: (timeScale: number) => import("three").KeyframeTrack;
                    trim: (startTime: number, endTime: number) => import("three").KeyframeTrack;
                    validate: () => boolean;
                    optimize: () => import("three").KeyframeTrack;
                    clone: () => import("three").KeyframeTrack;
                }[];
                blendMode: import("three").AnimationBlendMode;
                duration: number;
                uuid: string;
                results: any[];
                resetDuration: () => import("three").AnimationClip;
                trim: () => import("three").AnimationClip;
                validate: () => boolean;
                optimize: () => import("three").AnimationClip;
                clone: () => import("three").AnimationClip;
                toJSON: (clip: import("three").AnimationClip) => any;
            }[];
            userData: {
                [key: string]: any;
            };
            customDepthMaterial: {
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            };
            customDistanceMaterial: {
                alphaTest: number;
                alphaToCoverage: boolean;
                blendDst: import("three").BlendingDstFactor;
                blendDstAlpha: number | null;
                blendEquation: import("three").BlendingEquation;
                blendEquationAlpha: number | null;
                blending: import("three").Blending;
                blendSrc: import("three").BlendingSrcFactor | import("three").BlendingDstFactor;
                blendSrcAlpha: number | null;
                clipIntersection: boolean;
                clippingPlanes: any;
                clipShadows: boolean;
                colorWrite: boolean;
                defines: {
                    [key: string]: any;
                } | undefined;
                depthFunc: import("three").DepthModes;
                depthTest: boolean;
                depthWrite: boolean;
                id: number;
                stencilWrite: boolean;
                stencilFunc: import("three").StencilFunc;
                stencilRef: number;
                stencilWriteMask: number;
                stencilFuncMask: number;
                stencilFail: import("three").StencilOp;
                stencilZFail: import("three").StencilOp;
                stencilZPass: import("three").StencilOp;
                readonly isMaterial: true;
                name: string;
                needsUpdate: boolean;
                opacity: number;
                polygonOffset: boolean;
                polygonOffsetFactor: number;
                polygonOffsetUnits: number;
                precision: "highp" | "mediump" | "lowp" | null;
                premultipliedAlpha: boolean;
                forceSinglePass: boolean;
                dithering: boolean;
                side: import("three").Side;
                shadowSide: import("three").Side | null;
                toneMapped: boolean;
                transparent: boolean;
                type: string;
                uuid: string;
                vertexColors: boolean;
                visible: boolean;
                userData: any;
                version: number;
                clone: () => import("three").Material;
                copy: (material: import("three").Material) => import("three").Material;
                dispose: () => void;
                onBeforeCompile: (shader: import("three").Shader, renderer: import("three").WebGLRenderer) => void;
                customProgramCacheKey: () => string;
                setValues: (values: import("three").MaterialParameters) => void;
                toJSON: (meta?: any) => any;
                addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, import("three").Material>) => void;
                hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, import("three").Material>) => boolean;
                removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, import("three").Material>) => void;
                dispatchEvent: (event: import("three").Event) => void;
            };
            readonly isObject3D: true;
            onBeforeRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            onAfterRender: (renderer: import("three").WebGLRenderer, scene: import("three").Scene, camera: Camera, geometry: import("three").BufferGeometry, material: import("three").Material, group: import("three").Group) => void;
            applyMatrix4: (matrix: import("three").Matrix4) => void;
            applyQuaternion: (quaternion: import("three").Quaternion) => Camera;
            setRotationFromAxisAngle: (axis: import("three").Vector3, angle: number) => void;
            setRotationFromEuler: (euler: import("three").Euler) => void;
            setRotationFromMatrix: (m: import("three").Matrix4) => void;
            setRotationFromQuaternion: (q: import("three").Quaternion) => void;
            rotateOnAxis: (axis: import("three").Vector3, angle: number) => Camera;
            rotateOnWorldAxis: (axis: import("three").Vector3, angle: number) => Camera;
            rotateX: (angle: number) => Camera;
            rotateY: (angle: number) => Camera;
            rotateZ: (angle: number) => Camera;
            translateOnAxis: (axis: import("three").Vector3, distance: number) => Camera;
            translateX: (distance: number) => Camera;
            translateY: (distance: number) => Camera;
            translateZ: (distance: number) => Camera;
            localToWorld: (vector: import("three").Vector3) => import("three").Vector3;
            worldToLocal: (vector: import("three").Vector3) => import("three").Vector3;
            lookAt: {
                (vector: import("three").Vector3): void;
                (x: number, y: number, z: number): void;
            };
            add: (...object: import("three").Object3D<import("three").Event>[]) => Camera;
            remove: (...object: import("three").Object3D<import("three").Event>[]) => Camera;
            removeFromParent: () => Camera;
            clear: () => Camera;
            attach: (object: import("three").Object3D<import("three").Event>) => Camera;
            getObjectById: (id: number) => import("three").Object3D<import("three").Event> | undefined;
            getObjectByName: (name: string) => import("three").Object3D<import("three").Event> | undefined;
            getObjectByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event> | undefined;
            getObjectsByProperty: (name: string, value: any) => import("three").Object3D<import("three").Event>[];
            getWorldPosition: (target: import("three").Vector3) => import("three").Vector3;
            getWorldQuaternion: (target: import("three").Quaternion) => import("three").Quaternion;
            getWorldScale: (target: import("three").Vector3) => import("three").Vector3;
            raycast: (raycaster: import("three").Raycaster, intersects: import("three").Intersection<import("three").Object3D<import("three").Event>>[]) => void;
            traverse: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
            traverseVisible: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
            traverseAncestors: (callback: (object: import("three").Object3D<import("three").Event>) => any) => void;
            updateMatrix: () => void;
            updateWorldMatrix: (updateParents: boolean, updateChildren: boolean) => void;
            toJSON: (meta?: {
                geometries: any;
                materials: any;
                textures: any;
                images: any;
            } | undefined) => any;
            clone: (recursive?: boolean | undefined) => Camera;
            copy: (source: Camera, recursive?: boolean | undefined) => Camera;
            addEventListener: <T_6 extends string>(type: T_6, listener: import("three").EventListener<import("three").Event, T_6, Camera>) => void;
            hasEventListener: <T_7 extends string>(type: T_7, listener: import("three").EventListener<import("three").Event, T_7, Camera>) => boolean;
            removeEventListener: <T_8 extends string>(type: T_8, listener: import("three").EventListener<import("three").Event, T_8, Camera>) => void;
            dispatchEvent: (event: import("three").Event) => void;
        };
        domElement: HTMLElement;
        enabled: boolean;
        screen: {
            left: number;
            top: number;
            width: number;
            height: number;
        };
        rotateSpeed: number;
        zoomSpeed: number;
        panSpeed: number;
        noRotate: boolean;
        noZoom: boolean;
        noPan: boolean;
        noRoll: boolean;
        staticMoving: boolean;
        dynamicDampingFactor: number;
        minDistance: number;
        maxDistance: number;
        keys: string[];
        mouseButtons: {
            LEFT: import("three").MOUSE;
            MIDDLE: import("three").MOUSE;
            RIGHT: import("three").MOUSE;
        };
        target: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import("three").Vector3;
            setScalar: (scalar: number) => import("three").Vector3;
            setX: (x: number) => import("three").Vector3;
            setY: (y: number) => import("three").Vector3;
            setZ: (z: number) => import("three").Vector3;
            setComponent: (index: number, value: number) => import("three").Vector3;
            getComponent: (index: number) => number;
            clone: () => import("three").Vector3;
            copy: (v: import("three").Vector3) => import("three").Vector3;
            add: (v: import("three").Vector3) => import("three").Vector3;
            addScalar: (s: number) => import("three").Vector3;
            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
            addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            sub: (a: import("three").Vector3) => import("three").Vector3;
            subScalar: (s: number) => import("three").Vector3;
            subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            multiply: (v: import("three").Vector3) => import("three").Vector3;
            multiplyScalar: (s: number) => import("three").Vector3;
            multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
            applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
            project: (camera: Camera) => import("three").Vector3;
            unproject: (camera: Camera) => import("three").Vector3;
            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
            divide: (v: import("three").Vector3) => import("three").Vector3;
            divideScalar: (s: number) => import("three").Vector3;
            min: (v: import("three").Vector3) => import("three").Vector3;
            max: (v: import("three").Vector3) => import("three").Vector3;
            clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
            clampScalar: (min: number, max: number) => import("three").Vector3;
            clampLength: (min: number, max: number) => import("three").Vector3;
            floor: () => import("three").Vector3;
            ceil: () => import("three").Vector3;
            round: () => import("three").Vector3;
            roundToZero: () => import("three").Vector3;
            negate: () => import("three").Vector3;
            dot: (v: import("three").Vector3) => number;
            lengthSq: () => number;
            length: () => number;
            lengthManhattan: () => number;
            manhattanLength: () => number;
            manhattanDistanceTo: (v: import("three").Vector3) => number;
            normalize: () => import("three").Vector3;
            setLength: (l: number) => import("three").Vector3;
            lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
            lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
            cross: (a: import("three").Vector3) => import("three").Vector3;
            crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
            reflect: (vector: import("three").Vector3) => import("three").Vector3;
            angleTo: (v: import("three").Vector3) => number;
            distanceTo: (v: import("three").Vector3) => number;
            distanceToSquared: (v: import("three").Vector3) => number;
            distanceToManhattan: (v: import("three").Vector3) => number;
            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
            equals: (v: import("three").Vector3) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
            random: () => import("three").Vector3;
            randomDirection: () => import("three").Vector3;
        };
        position0: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import("three").Vector3;
            setScalar: (scalar: number) => import("three").Vector3;
            setX: (x: number) => import("three").Vector3;
            setY: (y: number) => import("three").Vector3;
            setZ: (z: number) => import("three").Vector3;
            setComponent: (index: number, value: number) => import("three").Vector3;
            getComponent: (index: number) => number;
            clone: () => import("three").Vector3;
            copy: (v: import("three").Vector3) => import("three").Vector3;
            add: (v: import("three").Vector3) => import("three").Vector3;
            addScalar: (s: number) => import("three").Vector3;
            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
            addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            sub: (a: import("three").Vector3) => import("three").Vector3;
            subScalar: (s: number) => import("three").Vector3;
            subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            multiply: (v: import("three").Vector3) => import("three").Vector3;
            multiplyScalar: (s: number) => import("three").Vector3;
            multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
            applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
            project: (camera: Camera) => import("three").Vector3;
            unproject: (camera: Camera) => import("three").Vector3;
            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
            divide: (v: import("three").Vector3) => import("three").Vector3;
            divideScalar: (s: number) => import("three").Vector3;
            min: (v: import("three").Vector3) => import("three").Vector3;
            max: (v: import("three").Vector3) => import("three").Vector3;
            clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
            clampScalar: (min: number, max: number) => import("three").Vector3;
            clampLength: (min: number, max: number) => import("three").Vector3;
            floor: () => import("three").Vector3;
            ceil: () => import("three").Vector3;
            round: () => import("three").Vector3;
            roundToZero: () => import("three").Vector3;
            negate: () => import("three").Vector3;
            dot: (v: import("three").Vector3) => number;
            lengthSq: () => number;
            length: () => number;
            lengthManhattan: () => number;
            manhattanLength: () => number;
            manhattanDistanceTo: (v: import("three").Vector3) => number;
            normalize: () => import("three").Vector3;
            setLength: (l: number) => import("three").Vector3;
            lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
            lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
            cross: (a: import("three").Vector3) => import("three").Vector3;
            crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
            reflect: (vector: import("three").Vector3) => import("three").Vector3;
            angleTo: (v: import("three").Vector3) => number;
            distanceTo: (v: import("three").Vector3) => number;
            distanceToSquared: (v: import("three").Vector3) => number;
            distanceToManhattan: (v: import("three").Vector3) => number;
            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
            equals: (v: import("three").Vector3) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
            random: () => import("three").Vector3;
            randomDirection: () => import("three").Vector3;
        };
        target0: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import("three").Vector3;
            setScalar: (scalar: number) => import("three").Vector3;
            setX: (x: number) => import("three").Vector3;
            setY: (y: number) => import("three").Vector3;
            setZ: (z: number) => import("three").Vector3;
            setComponent: (index: number, value: number) => import("three").Vector3;
            getComponent: (index: number) => number;
            clone: () => import("three").Vector3;
            copy: (v: import("three").Vector3) => import("three").Vector3;
            add: (v: import("three").Vector3) => import("three").Vector3;
            addScalar: (s: number) => import("three").Vector3;
            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
            addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            sub: (a: import("three").Vector3) => import("three").Vector3;
            subScalar: (s: number) => import("three").Vector3;
            subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            multiply: (v: import("three").Vector3) => import("three").Vector3;
            multiplyScalar: (s: number) => import("three").Vector3;
            multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
            applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
            project: (camera: Camera) => import("three").Vector3;
            unproject: (camera: Camera) => import("three").Vector3;
            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
            divide: (v: import("three").Vector3) => import("three").Vector3;
            divideScalar: (s: number) => import("three").Vector3;
            min: (v: import("three").Vector3) => import("three").Vector3;
            max: (v: import("three").Vector3) => import("three").Vector3;
            clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
            clampScalar: (min: number, max: number) => import("three").Vector3;
            clampLength: (min: number, max: number) => import("three").Vector3;
            floor: () => import("three").Vector3;
            ceil: () => import("three").Vector3;
            round: () => import("three").Vector3;
            roundToZero: () => import("three").Vector3;
            negate: () => import("three").Vector3;
            dot: (v: import("three").Vector3) => number;
            lengthSq: () => number;
            length: () => number;
            lengthManhattan: () => number;
            manhattanLength: () => number;
            manhattanDistanceTo: (v: import("three").Vector3) => number;
            normalize: () => import("three").Vector3;
            setLength: (l: number) => import("three").Vector3;
            lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
            lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
            cross: (a: import("three").Vector3) => import("three").Vector3;
            crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
            reflect: (vector: import("three").Vector3) => import("three").Vector3;
            angleTo: (v: import("three").Vector3) => number;
            distanceTo: (v: import("three").Vector3) => number;
            distanceToSquared: (v: import("three").Vector3) => number;
            distanceToManhattan: (v: import("three").Vector3) => number;
            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
            equals: (v: import("three").Vector3) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
            random: () => import("three").Vector3;
            randomDirection: () => import("three").Vector3;
        };
        up0: {
            x: number;
            y: number;
            z: number;
            readonly isVector3: true;
            set: (x: number, y: number, z: number) => import("three").Vector3;
            setScalar: (scalar: number) => import("three").Vector3;
            setX: (x: number) => import("three").Vector3;
            setY: (y: number) => import("three").Vector3;
            setZ: (z: number) => import("three").Vector3;
            setComponent: (index: number, value: number) => import("three").Vector3;
            getComponent: (index: number) => number;
            clone: () => import("three").Vector3;
            copy: (v: import("three").Vector3) => import("three").Vector3;
            add: (v: import("three").Vector3) => import("three").Vector3;
            addScalar: (s: number) => import("three").Vector3;
            addScaledVector: (v: import("three").Vector3, s: number) => import("three").Vector3;
            addVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            sub: (a: import("three").Vector3) => import("three").Vector3;
            subScalar: (s: number) => import("three").Vector3;
            subVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            multiply: (v: import("three").Vector3) => import("three").Vector3;
            multiplyScalar: (s: number) => import("three").Vector3;
            multiplyVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            applyEuler: (euler: import("three").Euler) => import("three").Vector3;
            applyAxisAngle: (axis: import("three").Vector3, angle: number) => import("three").Vector3;
            applyMatrix3: (m: import("three").Matrix3) => import("three").Vector3;
            applyNormalMatrix: (m: import("three").Matrix3) => import("three").Vector3;
            applyMatrix4: (m: import("three").Matrix4) => import("three").Vector3;
            applyQuaternion: (q: import("three").Quaternion) => import("three").Vector3;
            project: (camera: Camera) => import("three").Vector3;
            unproject: (camera: Camera) => import("three").Vector3;
            transformDirection: (m: import("three").Matrix4) => import("three").Vector3;
            divide: (v: import("three").Vector3) => import("three").Vector3;
            divideScalar: (s: number) => import("three").Vector3;
            min: (v: import("three").Vector3) => import("three").Vector3;
            max: (v: import("three").Vector3) => import("three").Vector3;
            clamp: (min: import("three").Vector3, max: import("three").Vector3) => import("three").Vector3;
            clampScalar: (min: number, max: number) => import("three").Vector3;
            clampLength: (min: number, max: number) => import("three").Vector3;
            floor: () => import("three").Vector3;
            ceil: () => import("three").Vector3;
            round: () => import("three").Vector3;
            roundToZero: () => import("three").Vector3;
            negate: () => import("three").Vector3;
            dot: (v: import("three").Vector3) => number;
            lengthSq: () => number;
            length: () => number;
            lengthManhattan: () => number;
            manhattanLength: () => number;
            manhattanDistanceTo: (v: import("three").Vector3) => number;
            normalize: () => import("three").Vector3;
            setLength: (l: number) => import("three").Vector3;
            lerp: (v: import("three").Vector3, alpha: number) => import("three").Vector3;
            lerpVectors: (v1: import("three").Vector3, v2: import("three").Vector3, alpha: number) => import("three").Vector3;
            cross: (a: import("three").Vector3) => import("three").Vector3;
            crossVectors: (a: import("three").Vector3, b: import("three").Vector3) => import("three").Vector3;
            projectOnVector: (v: import("three").Vector3) => import("three").Vector3;
            projectOnPlane: (planeNormal: import("three").Vector3) => import("three").Vector3;
            reflect: (vector: import("three").Vector3) => import("three").Vector3;
            angleTo: (v: import("three").Vector3) => number;
            distanceTo: (v: import("three").Vector3) => number;
            distanceToSquared: (v: import("three").Vector3) => number;
            distanceToManhattan: (v: import("three").Vector3) => number;
            setFromSpherical: (s: import("three").Spherical) => import("three").Vector3;
            setFromSphericalCoords: (r: number, phi: number, theta: number) => import("three").Vector3;
            setFromCylindrical: (s: import("three").Cylindrical) => import("three").Vector3;
            setFromCylindricalCoords: (radius: number, theta: number, y: number) => import("three").Vector3;
            setFromMatrixPosition: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixScale: (m: import("three").Matrix4) => import("three").Vector3;
            setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => import("three").Vector3;
            setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => import("three").Vector3;
            setFromEuler: (e: import("three").Euler) => import("three").Vector3;
            equals: (v: import("three").Vector3) => boolean;
            fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => import("three").Vector3;
            toArray: {
                (array?: number[] | undefined, offset?: number | undefined): number[];
                (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
            };
            fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => import("three").Vector3;
            random: () => import("three").Vector3;
            randomDirection: () => import("three").Vector3;
        };
        update: () => void;
        reset: () => void;
        dispose: () => void;
        checkDistances: () => void;
        zoomCamera: () => void;
        panCamera: () => void;
        rotateCamera: () => void;
        handleResize: () => void;
        addEventListener: <T_9 extends string>(type: T_9, listener: import("three").EventListener<import("three").Event, T_9, TrackballControls>) => void;
        hasEventListener: <T_10 extends string>(type: T_10, listener: import("three").EventListener<import("three").Event, T_10, TrackballControls>) => boolean;
        removeEventListener: <T_11 extends string>(type: T_11, listener: import("three").EventListener<import("three").Event, T_11, TrackballControls>) => void;
        dispatchEvent: (event: import("three").Event) => void;
    } | null>;
    camera: Camera;
    canvas: Ref<HTMLCanvasElement>;
    applyProps: () => void;
    boundCamera: boolean;
    tryBindCamera: () => void;
    readonly Camera: typeof Camera;
    readonly TrackballControls: typeof TrackballControls;
    inject: typeof inject;
    ref: typeof ref;
    watch: typeof watch;
    readonly handlePropCallback: (props: {
        [key: string]: any;
    }, prop: string, fn: () => void) => void;
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    minDistance: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    maxDistance: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    panSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    rotateSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    zoomSpeed: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
}>>, {
    minDistance: number;
    maxDistance: number;
    zoomSpeed: number;
    rotateSpeed: number;
    panSpeed: number;
}>;
export default _sfc_main;
