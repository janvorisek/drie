import { inject, reactive } from "vue";
import { BufferGeometry, Mesh, Vector3 } from "three";
import { ParametricGeometry } from "three/examples/jsm/geometries/ParametricGeometry";
import { ParametricGeometries } from "three/examples/jsm/geometries/ParametricGeometries";
import { copyGeo } from "../utils";
export interface Props {
    /**
     * Name of the geometry.
     */
    name?: string;
    /**
     * A function that takes in a `u` and `v` value each between 0 and 1 and modifies a third Vector3 argument.
     * Default is a function that generates a klein bottle
     */
    function?: (u: number, v: number, target: Vector3) => void;
    /**
     * The count of slices to use for the parametric function.
     */
    slices?: number;
    /**
     * The count of stacks to use for the parametric function.
     */
    stacks?: number;
}
declare const _sfc_main: import("vue").DefineComponent<{
    name: {
        type: StringConstructor;
        required: false;
        default: string;
    };
    function: {
        type: FunctionConstructor;
        required: false;
        default: typeof ParametricGeometries.klein;
    };
    slices: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    stacks: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
}, {
    props: any;
    makePlane: (f: (u: number, v: number, target: Vector3) => void | undefined, slices: number | undefined, stacks: number | undefined) => ParametricGeometry;
    three: {
        id: number;
        uuid: string;
        name: string;
        type: string;
        index: {
            name: string;
            array: {
                [x: number]: number;
                readonly length: number;
            };
            itemSize: number;
            usage: import("three").Usage;
            updateRange: {
                offset: number;
                count: number;
            };
            version: number;
            normalized: boolean;
            count: number;
            needsUpdate: boolean;
            readonly isBufferAttribute: true;
            onUploadCallback: () => void;
            onUpload: (callback: () => void) => import("three").BufferAttribute;
            setUsage: (usage: import("three").Usage) => import("three").BufferAttribute;
            clone: () => import("three").BufferAttribute;
            copy: (source: import("three").BufferAttribute) => import("three").BufferAttribute;
            copyAt: (index1: number, attribute: import("three").BufferAttribute, index2: number) => import("three").BufferAttribute;
            copyArray: (array: ArrayLike<number>) => import("three").BufferAttribute;
            applyMatrix3: (m: import("three").Matrix3) => import("three").BufferAttribute;
            applyMatrix4: (m: import("three").Matrix4) => import("three").BufferAttribute;
            applyNormalMatrix: (m: import("three").Matrix3) => import("three").BufferAttribute;
            transformDirection: (m: import("three").Matrix4) => import("three").BufferAttribute;
            set: (value: ArrayLike<number> | ArrayBufferView, offset?: number | undefined) => import("three").BufferAttribute;
            getX: (index: number) => number;
            setX: (index: number, x: number) => import("three").BufferAttribute;
            getY: (index: number) => number;
            setY: (index: number, y: number) => import("three").BufferAttribute;
            getZ: (index: number) => number;
            setZ: (index: number, z: number) => import("three").BufferAttribute;
            getW: (index: number) => number;
            setW: (index: number, z: number) => import("three").BufferAttribute;
            setXY: (index: number, x: number, y: number) => import("three").BufferAttribute;
            setXYZ: (index: number, x: number, y: number, z: number) => import("three").BufferAttribute;
            setXYZW: (index: number, x: number, y: number, z: number, w: number) => import("three").BufferAttribute;
            toJSON: () => {
                itemSize: number;
                type: string;
                array: number[];
                normalized: boolean;
            };
        } | null;
        attributes: {
            [name: string]: import("three").BufferAttribute | import("three").InterleavedBufferAttribute | import("three").GLBufferAttribute;
        };
        morphAttributes: {
            [name: string]: (import("three").BufferAttribute | import("three").InterleavedBufferAttribute)[];
        };
        morphTargetsRelative: boolean;
        groups: {
            start: number;
            count: number;
            materialIndex?: number | undefined;
        }[];
        boundingBox: {
            min: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: import("three").Matrix4) => Vector3;
                applyQuaternion: (q: import("three").Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: import("three").Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
            };
            max: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: import("three").Matrix4) => Vector3;
                applyQuaternion: (q: import("three").Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: import("three").Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
            };
            readonly isBox3: true;
            set: (min: Vector3, max: Vector3) => import("three").Box3;
            setFromArray: (array: ArrayLike<number>) => import("three").Box3;
            setFromBufferAttribute: (bufferAttribute: import("three").BufferAttribute) => import("three").Box3;
            setFromPoints: (points: Vector3[]) => import("three").Box3;
            setFromCenterAndSize: (center: Vector3, size: Vector3) => import("three").Box3;
            setFromObject: (object: import("three").Object3D<import("three").Event>, precise?: boolean | undefined) => import("three").Box3;
            clone: () => import("three").Box3;
            copy: (box: import("three").Box3) => import("three").Box3;
            makeEmpty: () => import("three").Box3;
            isEmpty: () => boolean;
            getCenter: (target: Vector3) => Vector3;
            getSize: (target: Vector3) => Vector3;
            expandByPoint: (point: Vector3) => import("three").Box3;
            expandByVector: (vector: Vector3) => import("three").Box3;
            expandByScalar: (scalar: number) => import("three").Box3;
            expandByObject: (object: import("three").Object3D<import("three").Event>, precise?: boolean | undefined) => import("three").Box3;
            containsPoint: (point: Vector3) => boolean;
            containsBox: (box: import("three").Box3) => boolean;
            getParameter: (point: Vector3, target: Vector3) => Vector3;
            intersectsBox: (box: import("three").Box3) => boolean;
            intersectsSphere: (sphere: import("three").Sphere) => boolean;
            intersectsPlane: (plane: import("three").Plane) => boolean;
            intersectsTriangle: (triangle: import("three").Triangle) => boolean;
            clampPoint: (point: Vector3, target: Vector3) => Vector3;
            distanceToPoint: (point: Vector3) => number;
            getBoundingSphere: (target: import("three").Sphere) => import("three").Sphere;
            intersect: (box: import("three").Box3) => import("three").Box3;
            union: (box: import("three").Box3) => import("three").Box3;
            applyMatrix4: (matrix: import("three").Matrix4) => import("three").Box3;
            translate: (offset: Vector3) => import("three").Box3;
            equals: (box: import("three").Box3) => boolean;
            empty: () => any;
            isIntersectionBox: (b: any) => any;
            isIntersectionSphere: (s: any) => any;
        } | null;
        boundingSphere: {
            center: {
                x: number;
                y: number;
                z: number;
                readonly isVector3: true;
                set: (x: number, y: number, z: number) => Vector3;
                setScalar: (scalar: number) => Vector3;
                setX: (x: number) => Vector3;
                setY: (y: number) => Vector3;
                setZ: (z: number) => Vector3;
                setComponent: (index: number, value: number) => Vector3;
                getComponent: (index: number) => number;
                clone: () => Vector3;
                copy: (v: Vector3) => Vector3;
                add: (v: Vector3) => Vector3;
                addScalar: (s: number) => Vector3;
                addScaledVector: (v: Vector3, s: number) => Vector3;
                addVectors: (a: Vector3, b: Vector3) => Vector3;
                sub: (a: Vector3) => Vector3;
                subScalar: (s: number) => Vector3;
                subVectors: (a: Vector3, b: Vector3) => Vector3;
                multiply: (v: Vector3) => Vector3;
                multiplyScalar: (s: number) => Vector3;
                multiplyVectors: (a: Vector3, b: Vector3) => Vector3;
                applyEuler: (euler: import("three").Euler) => Vector3;
                applyAxisAngle: (axis: Vector3, angle: number) => Vector3;
                applyMatrix3: (m: import("three").Matrix3) => Vector3;
                applyNormalMatrix: (m: import("three").Matrix3) => Vector3;
                applyMatrix4: (m: import("three").Matrix4) => Vector3;
                applyQuaternion: (q: import("three").Quaternion) => Vector3;
                project: (camera: import("three").Camera) => Vector3;
                unproject: (camera: import("three").Camera) => Vector3;
                transformDirection: (m: import("three").Matrix4) => Vector3;
                divide: (v: Vector3) => Vector3;
                divideScalar: (s: number) => Vector3;
                min: (v: Vector3) => Vector3;
                max: (v: Vector3) => Vector3;
                clamp: (min: Vector3, max: Vector3) => Vector3;
                clampScalar: (min: number, max: number) => Vector3;
                clampLength: (min: number, max: number) => Vector3;
                floor: () => Vector3;
                ceil: () => Vector3;
                round: () => Vector3;
                roundToZero: () => Vector3;
                negate: () => Vector3;
                dot: (v: Vector3) => number;
                lengthSq: () => number;
                length: () => number;
                lengthManhattan: () => number;
                manhattanLength: () => number;
                manhattanDistanceTo: (v: Vector3) => number;
                normalize: () => Vector3;
                setLength: (l: number) => Vector3;
                lerp: (v: Vector3, alpha: number) => Vector3;
                lerpVectors: (v1: Vector3, v2: Vector3, alpha: number) => Vector3;
                cross: (a: Vector3) => Vector3;
                crossVectors: (a: Vector3, b: Vector3) => Vector3;
                projectOnVector: (v: Vector3) => Vector3;
                projectOnPlane: (planeNormal: Vector3) => Vector3;
                reflect: (vector: Vector3) => Vector3;
                angleTo: (v: Vector3) => number;
                distanceTo: (v: Vector3) => number;
                distanceToSquared: (v: Vector3) => number;
                distanceToManhattan: (v: Vector3) => number;
                setFromSpherical: (s: import("three").Spherical) => Vector3;
                setFromSphericalCoords: (r: number, phi: number, theta: number) => Vector3;
                setFromCylindrical: (s: import("three").Cylindrical) => Vector3;
                setFromCylindricalCoords: (radius: number, theta: number, y: number) => Vector3;
                setFromMatrixPosition: (m: import("three").Matrix4) => Vector3;
                setFromMatrixScale: (m: import("three").Matrix4) => Vector3;
                setFromMatrixColumn: (matrix: import("three").Matrix4, index: number) => Vector3;
                setFromMatrix3Column: (matrix: import("three").Matrix3, index: number) => Vector3;
                setFromEuler: (e: import("three").Euler) => Vector3;
                equals: (v: Vector3) => boolean;
                fromArray: (array: number[] | ArrayLike<number>, offset?: number | undefined) => Vector3;
                toArray: {
                    (array?: number[] | undefined, offset?: number | undefined): number[];
                    (array?: import("three").Vector3Tuple | undefined, offset?: 0 | undefined): import("three").Vector3Tuple;
                    (array: ArrayLike<number>, offset?: number | undefined): ArrayLike<number>;
                };
                fromBufferAttribute: (attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute, index: number) => Vector3;
                random: () => Vector3;
                randomDirection: () => Vector3;
            };
            radius: number;
            set: (center: Vector3, radius: number) => import("three").Sphere;
            setFromPoints: (points: Vector3[], optionalCenter?: Vector3 | undefined) => import("three").Sphere;
            clone: () => import("three").Sphere;
            copy: (sphere: import("three").Sphere) => import("three").Sphere;
            expandByPoint: (point: Vector3) => import("three").Sphere;
            isEmpty: () => boolean;
            makeEmpty: () => import("three").Sphere;
            containsPoint: (point: Vector3) => boolean;
            distanceToPoint: (point: Vector3) => number;
            intersectsSphere: (sphere: import("three").Sphere) => boolean;
            intersectsBox: (box: import("three").Box3) => boolean;
            intersectsPlane: (plane: import("three").Plane) => boolean;
            clampPoint: (point: Vector3, target: Vector3) => Vector3;
            getBoundingBox: (target: import("three").Box3) => import("three").Box3;
            applyMatrix4: (matrix: import("three").Matrix4) => import("three").Sphere;
            translate: (offset: Vector3) => import("three").Sphere;
            equals: (sphere: import("three").Sphere) => boolean;
            union: (sphere: import("three").Sphere) => import("three").Sphere;
            empty: () => any;
        } | null;
        drawRange: {
            start: number;
            count: number;
        };
        userData: {
            [key: string]: any;
        };
        readonly isBufferGeometry: true;
        getIndex: () => import("three").BufferAttribute | null;
        setIndex: (index: number[] | import("three").BufferAttribute | null) => BufferGeometry;
        setAttribute: (name: import("three").BuiltinShaderAttributeName | (string & {}), attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute | import("three").GLBufferAttribute) => BufferGeometry;
        getAttribute: (name: import("three").BuiltinShaderAttributeName | (string & {})) => import("three").BufferAttribute | import("three").InterleavedBufferAttribute | import("three").GLBufferAttribute;
        deleteAttribute: (name: import("three").BuiltinShaderAttributeName | (string & {})) => BufferGeometry;
        hasAttribute: (name: import("three").BuiltinShaderAttributeName | (string & {})) => boolean;
        addGroup: (start: number, count: number, materialIndex?: number | undefined) => void;
        clearGroups: () => void;
        setDrawRange: (start: number, count: number) => void;
        applyMatrix4: (matrix: import("three").Matrix4) => BufferGeometry;
        applyQuaternion: (q: import("three").Quaternion) => BufferGeometry;
        rotateX: (angle: number) => BufferGeometry;
        rotateY: (angle: number) => BufferGeometry;
        rotateZ: (angle: number) => BufferGeometry;
        translate: (x: number, y: number, z: number) => BufferGeometry;
        scale: (x: number, y: number, z: number) => BufferGeometry;
        lookAt: (v: Vector3) => void;
        center: () => BufferGeometry;
        setFromPoints: (points: Vector3[] | import("three").Vector2[]) => BufferGeometry;
        computeBoundingBox: () => void;
        computeBoundingSphere: () => void;
        computeTangents: () => void;
        computeVertexNormals: () => void;
        normalizeNormals: () => void;
        toNonIndexed: () => BufferGeometry;
        toJSON: () => any;
        clone: () => BufferGeometry;
        copy: (source: BufferGeometry) => BufferGeometry;
        dispose: () => void;
        drawcalls: any;
        offsets: any;
        addIndex: (index: any) => void;
        addDrawCall: (start: any, count: any, indexOffset?: any) => void;
        clearDrawCalls: () => void;
        addAttribute: {
            (name: string, attribute: import("three").BufferAttribute | import("three").InterleavedBufferAttribute): BufferGeometry;
            (name: any, array: any, itemSize: any): any;
        };
        removeAttribute: (name: string) => BufferGeometry;
        addEventListener: <T extends string>(type: T, listener: import("three").EventListener<import("three").Event, T, BufferGeometry>) => void;
        hasEventListener: <T_1 extends string>(type: T_1, listener: import("three").EventListener<import("three").Event, T_1, BufferGeometry>) => boolean;
        removeEventListener: <T_2 extends string>(type: T_2, listener: import("three").EventListener<import("three").Event, T_2, BufferGeometry>) => void;
        dispatchEvent: (event: import("three").Event) => void;
    };
    mesh: Mesh<BufferGeometry, import("three").Material | import("three").Material[]> | null;
    addGeometry: (g: BufferGeometry) => void;
    redoGeometry: () => void;
    inject: typeof inject;
    onMounted: (hook: () => any, target?: import("vue").ComponentInternalInstance | null | undefined) => false | Function | undefined;
    reactive: typeof reactive;
    readonly BufferGeometry: typeof BufferGeometry;
    readonly Mesh: typeof Mesh;
    readonly Vector3: typeof Vector3;
    readonly ParametricGeometry: typeof ParametricGeometry;
    readonly ParametricGeometries: typeof ParametricGeometries;
    readonly handlePropCallback: (props: {
        [key: string]: any;
    }, prop: string, fn: () => void) => void;
    readonly copyGeo: typeof copyGeo;
    readonly EventBus: {
        geometryChanged: import("ts-event-bus").Slot<BufferGeometry, void>;
        object3DChanged: import("ts-event-bus").Slot<import("three").Object3D<import("three").Event>, void>;
        object3DTranslated: import("ts-event-bus").Slot<import("three").Object3D<import("three").Event>, void>;
        sayHello: import("ts-event-bus").Slot<string, void>;
        getTime: import("ts-event-bus").Slot<null, string>;
        multiply: import("ts-event-bus").Slot<{
            a: number;
            b: number;
        }, number>;
        ping: import("ts-event-bus").Slot<void, void>;
    };
}, unknown, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps, Readonly<import("vue").ExtractPropTypes<{
    name: {
        type: StringConstructor;
        required: false;
        default: string;
    };
    function: {
        type: FunctionConstructor;
        required: false;
        default: typeof ParametricGeometries.klein;
    };
    slices: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
    stacks: {
        type: NumberConstructor;
        required: false;
        default: number;
    };
}>>, {
    function: Function;
    name: string;
    slices: number;
    stacks: number;
}>;
export default _sfc_main;
