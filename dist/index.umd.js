(function(M,l){typeof exports=="object"&&typeof module<"u"?l(exports,require("vue"),require("three")):typeof define=="function"&&define.amd?define(["exports","vue","three"],l):(M=typeof globalThis<"u"?globalThis:M||self,l(M["@janvorisek/drie"]={},M.Vue,M.three))})(this,function(M,l,c){"use strict";const W=r=>r===void 0?new c.Vector3(0,0,0):"x"in r?new c.Vector3(r.x,r.y,r.z):new c.Vector3(r[0],r[1],r[2]),J=(r,i,t)=>{t[r].isVector3?t[r].set(i.x,i.y,i.z):"isEuler"in t[r]&&t[r].setFromVector3(i)},S=(r,i,t,e=!0)=>{if(r[i]!==void 0){const n=W(r[i]);if("isGroup"in t)for(const o of t.children)S(r,i,o,!1);else J(i,n,t)}e&&l.watch(()=>r[i],()=>{if(r[i]!==void 0){const n=W(r[i]);if("isGroup"in t)for(const o of t.children)S(r,i,o,!1);else J(i,n,t)}})},P=(r,i,t)=>{l.watch(()=>r[i],()=>t)};function Q(r){if(r.children.length>0)for(let i=r.children.length-1;i>=0;i--)Q(r.children[i]);if(r.geometry&&r.geometry.dispose(),r.material)if(r.material.length)for(let i=0;i<r.material.length;++i)r.material[i].map&&r.material[i].map.dispose(),r.material[i].lightMap&&r.material[i].lightMap.dispose(),r.material[i].bumpMap&&r.material[i].bumpMap.dispose(),r.material[i].normalMap&&r.material[i].normalMap.dispose(),r.material[i].specularMap&&r.material[i].specularMap.dispose(),r.material[i].envMap&&r.material[i].envMap.dispose(),r.material[i].dispose();else r.material.map&&r.material.map.dispose(),r.material.lightMap&&r.material.lightMap.dispose(),r.material.bumpMap&&r.material.bumpMap.dispose(),r.material.normalMap&&r.material.normalMap.dispose(),r.material.specularMap&&r.material.specularMap.dispose(),r.material.envMap&&r.material.envMap.dispose(),r.material.dispose();return r.removeFromParent(),!0}const ee=l.defineComponent({__name:"Renderer",props:{camera:null,autoResize:{type:Boolean,default:!0},onBeforeRender:{type:Function,default:()=>{}},antialias:{type:Boolean,default:!1},alpha:{type:Boolean,default:!1},shadowMapEnabled:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r;let e=null;const n=[];let o=null;const s=l.ref([]),d=l.ref([]),f=l.ref();l.provide("canvas",f);let w=Date.now();const L=1e3/30;l.watch(()=>t.camera,m=>g(m));const g=m=>{if(m){const _=s.value.find(y=>y.name===m);_===void 0&&(o=null),o=_}else o=s.value[0]};function b(m){e!==null&&(e.shadowMap.enabled=m.shadowMapEnabled)}l.onMounted(()=>{e=new c.WebGLRenderer({canvas:f.value,antialias:t.antialias,alpha:!0}),e.setSize(1,1),b(t),g(t.camera),new ResizeObserver(_=>{_.forEach(y=>{e&&t.autoResize&&e.setSize(y.contentRect.width,y.contentRect.height)})}).observe(f.value.parentElement),u()}),l.onUnmounted(()=>{for(let m of n)Q(m)});function u(){requestAnimationFrame(u);const m=Date.now(),_=m-w;if(!(_<L)){if(w=m-_%L,t.onBeforeRender&&t.onBeforeRender(),d.value.length>0&&o)for(const y of d.value)y.value!==null&&(y.value.object.uuid===o.uuid?(y.value.enabled=!0,y.value.update()):y.value.enabled=!1);if(o&&e)for(const y of n)e.render(y,o)}}return b(t),l.watch(()=>t.shadowMapEnabled,()=>b(t)),l.provide("addCamera",m=>s.value.push(m)),l.provide("addScene",m=>n.push(m)),l.provide("addControls",m=>d.value.push(m)),i({three:e}),(m,_)=>(l.openBlock(),l.createElementBlock(l.Fragment,null,[l.renderSlot(m.$slots,"default"),l.createElementVNode("canvas",{ref_key:"canvas",ref:f},null,512)],64))}}),te=l.defineComponent({__name:"Scene",props:{background:{default:16777215}},setup(r,{expose:i}){const t=r,e=new c.Scene;l.provide("scene",e),l.inject("addScene")(e);function n(o){o.background&&(e.background=new c.Color(o.background))}return n(t),l.watch(()=>t.background,()=>n(t)),i({three:e}),(o,s)=>l.renderSlot(o.$slots,"default")}}),Ue={name:"PerspectiveCamera"},ne=l.defineComponent({...Ue,props:{name:{default:""},up:{default:()=>[0,1,0]},position:{default:()=>[0,0,0]},lookAt:{default:()=>[0,0,0]}},setup(r,{expose:i}){const t=r,e=new c.PerspectiveCamera(75,window.innerWidth/window.innerHeight*1e3,.1,1e3);l.inject("addCamera")(e);const n=l.inject("canvas");l.onMounted(()=>{t.name&&(e.name=t.name),new ResizeObserver(d=>{d.forEach(f=>{e.aspect=f.contentRect.width/f.contentRect.height,e.updateProjectionMatrix()})}).observe(n.value)}),S(t,"position",e),S(t,"up",e),S(t,"lookAt",e);function o(s){}return l.watch(t,()=>void 0),l.provide("parentCamera",e),i({three:e}),(s,d)=>l.renderSlot(s.$slots,"default")}}),Ge={name:"OrthographicCamera"},oe=l.defineComponent({...Ge,props:{name:{default:""},up:{default:()=>[0,1,0]},position:{default:()=>[0,0,0]},lookAt:{default:()=>[0,0,0]}},setup(r,{expose:i}){const t=r,e=new c.OrthographicCamera(-30,30,30,-30,.1,1e3);e.lookAt(0,0,0),e.updateProjectionMatrix(),l.inject("addCamera")(e),l.onMounted(()=>{t.name&&(e.name=t.name)}),S(t,"position",e),S(t,"up",e),S(t,"lookAt",e);function n(o){}return l.watch(t,()=>void 0),l.provide("parentCamera",e),i({three:e}),(o,s)=>l.renderSlot(o.$slots,"default")}}),ae={type:"change"},H={type:"start"},ie={type:"end"};class He extends c.EventDispatcher{constructor(i,t){super(),t===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=i,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new c.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:c.MOUSE.ROTATE,MIDDLE:c.MOUSE.DOLLY,RIGHT:c.MOUSE.PAN},this.touches={ONE:c.TOUCH.ROTATE,TWO:c.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return d.phi},this.getAzimuthalAngle=function(){return d.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(a){a.addEventListener("keydown",ke),this._domElementKeyEvents=a},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(ae),e.update(),o=n.NONE},this.update=function(){const a=new c.Vector3,h=new c.Quaternion().setFromUnitVectors(i.up,new c.Vector3(0,1,0)),T=h.clone().invert(),j=new c.Vector3,I=new c.Quaternion,$=2*Math.PI;return function(){const Fe=e.object.position;a.copy(Fe).sub(e.target),a.applyQuaternion(h),d.setFromVector3(a),e.autoRotate&&o===n.NONE&&N(F()),e.enableDamping?(d.theta+=f.theta*e.dampingFactor,d.phi+=f.phi*e.dampingFactor):(d.theta+=f.theta,d.phi+=f.phi);let B=e.minAzimuthAngle,k=e.maxAzimuthAngle;return isFinite(B)&&isFinite(k)&&(B<-Math.PI?B+=$:B>Math.PI&&(B-=$),k<-Math.PI?k+=$:k>Math.PI&&(k-=$),B<=k?d.theta=Math.max(B,Math.min(k,d.theta)):d.theta=d.theta>(B+k)/2?Math.max(B,d.theta):Math.min(k,d.theta)),d.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,d.phi)),d.makeSafe(),d.radius*=w,d.radius=Math.max(e.minDistance,Math.min(e.maxDistance,d.radius)),e.enableDamping===!0?e.target.addScaledVector(L,e.dampingFactor):e.target.add(L),a.setFromSpherical(d),a.applyQuaternion(T),Fe.copy(e.target).add(a),e.object.lookAt(e.target),e.enableDamping===!0?(f.theta*=1-e.dampingFactor,f.phi*=1-e.dampingFactor,L.multiplyScalar(1-e.dampingFactor)):(f.set(0,0,0),L.set(0,0,0)),w=1,g||j.distanceToSquared(e.object.position)>s||8*(1-I.dot(e.object.quaternion))>s?(e.dispatchEvent(ae),j.copy(e.object.position),I.copy(e.object.quaternion),g=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",Ne),e.domElement.removeEventListener("pointerdown",Re),e.domElement.removeEventListener("pointercancel",Ie),e.domElement.removeEventListener("wheel",Be),e.domElement.removeEventListener("pointermove",X),e.domElement.removeEventListener("pointerup",K),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",ke)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=n.NONE;const s=1e-6,d=new c.Spherical,f=new c.Spherical;let w=1;const L=new c.Vector3;let g=!1;const b=new c.Vector2,u=new c.Vector2,m=new c.Vector2,_=new c.Vector2,y=new c.Vector2,O=new c.Vector2,C=new c.Vector2,A=new c.Vector2,x=new c.Vector2,p=[],z={};function F(){return 2*Math.PI/60/60*e.autoRotateSpeed}function V(){return Math.pow(.95,e.zoomSpeed)}function N(a){f.theta-=a}function E(a){f.phi-=a}const R=function(){const a=new c.Vector3;return function(T,j){a.setFromMatrixColumn(j,0),a.multiplyScalar(-T),L.add(a)}}(),Ee=function(){const a=new c.Vector3;return function(T,j){e.screenSpacePanning===!0?a.setFromMatrixColumn(j,1):(a.setFromMatrixColumn(j,0),a.crossVectors(e.object.up,a)),a.multiplyScalar(T),L.add(a)}}(),v=function(){const a=new c.Vector3;return function(T,j){const I=e.domElement;if(e.object.isPerspectiveCamera){const $=e.object.position;a.copy($).sub(e.target);let G=a.length();G*=Math.tan(e.object.fov/2*Math.PI/180),R(2*T*G/I.clientHeight,e.object.matrix),Ee(2*j*G/I.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(R(T*(e.object.right-e.object.left)/e.object.zoom/I.clientWidth,e.object.matrix),Ee(j*(e.object.top-e.object.bottom)/e.object.zoom/I.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function Z(a){e.object.isPerspectiveCamera?w/=a:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*a)),e.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function Le(a){e.object.isPerspectiveCamera?w*=a:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/a)),e.object.updateProjectionMatrix(),g=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function Oe(a){b.set(a.clientX,a.clientY)}function mt(a){C.set(a.clientX,a.clientY)}function xe(a){_.set(a.clientX,a.clientY)}function ut(a){u.set(a.clientX,a.clientY),m.subVectors(u,b).multiplyScalar(e.rotateSpeed);const h=e.domElement;N(2*Math.PI*m.x/h.clientHeight),E(2*Math.PI*m.y/h.clientHeight),b.copy(u),e.update()}function ft(a){A.set(a.clientX,a.clientY),x.subVectors(A,C),x.y>0?Z(V()):x.y<0&&Le(V()),C.copy(A),e.update()}function ht(a){y.set(a.clientX,a.clientY),O.subVectors(y,_).multiplyScalar(e.panSpeed),v(O.x,O.y),_.copy(y),e.update()}function pt(a){a.deltaY<0?Le(V()):a.deltaY>0&&Z(V()),e.update()}function gt(a){let h=!1;switch(a.code){case e.keys.UP:v(0,e.keyPanSpeed),h=!0;break;case e.keys.BOTTOM:v(0,-e.keyPanSpeed),h=!0;break;case e.keys.LEFT:v(e.keyPanSpeed,0),h=!0;break;case e.keys.RIGHT:v(-e.keyPanSpeed,0),h=!0;break}h&&(a.preventDefault(),e.update())}function Ce(){if(p.length===1)b.set(p[0].pageX,p[0].pageY);else{const a=.5*(p[0].pageX+p[1].pageX),h=.5*(p[0].pageY+p[1].pageY);b.set(a,h)}}function Te(){if(p.length===1)_.set(p[0].pageX,p[0].pageY);else{const a=.5*(p[0].pageX+p[1].pageX),h=.5*(p[0].pageY+p[1].pageY);_.set(a,h)}}function je(){const a=p[0].pageX-p[1].pageX,h=p[0].pageY-p[1].pageY,T=Math.sqrt(a*a+h*h);C.set(0,T)}function yt(){e.enableZoom&&je(),e.enablePan&&Te()}function wt(){e.enableZoom&&je(),e.enableRotate&&Ce()}function ze(a){if(p.length==1)u.set(a.pageX,a.pageY);else{const T=q(a),j=.5*(a.pageX+T.x),I=.5*(a.pageY+T.y);u.set(j,I)}m.subVectors(u,b).multiplyScalar(e.rotateSpeed);const h=e.domElement;N(2*Math.PI*m.x/h.clientHeight),E(2*Math.PI*m.y/h.clientHeight),b.copy(u)}function Ve(a){if(p.length===1)y.set(a.pageX,a.pageY);else{const h=q(a),T=.5*(a.pageX+h.x),j=.5*(a.pageY+h.y);y.set(T,j)}O.subVectors(y,_).multiplyScalar(e.panSpeed),v(O.x,O.y),_.copy(y)}function De(a){const h=q(a),T=a.pageX-h.x,j=a.pageY-h.y,I=Math.sqrt(T*T+j*j);A.set(0,I),x.set(0,Math.pow(A.y/C.y,e.zoomSpeed)),Z(x.y),C.copy(A)}function bt(a){e.enableZoom&&De(a),e.enablePan&&Ve(a)}function _t(a){e.enableZoom&&De(a),e.enableRotate&&ze(a)}function Re(a){e.enabled!==!1&&(p.length===0&&(e.domElement.setPointerCapture(a.pointerId),e.domElement.addEventListener("pointermove",X),e.domElement.addEventListener("pointerup",K)),Et(a),a.pointerType==="touch"?St(a):Mt(a))}function X(a){e.enabled!==!1&&(a.pointerType==="touch"?At(a):Pt(a))}function K(a){ve(a),p.length===0&&(e.domElement.releasePointerCapture(a.pointerId),e.domElement.removeEventListener("pointermove",X),e.domElement.removeEventListener("pointerup",K)),e.dispatchEvent(ie),o=n.NONE}function Ie(a){ve(a)}function Mt(a){let h;switch(a.button){case 0:h=e.mouseButtons.LEFT;break;case 1:h=e.mouseButtons.MIDDLE;break;case 2:h=e.mouseButtons.RIGHT;break;default:h=-1}switch(h){case c.MOUSE.DOLLY:if(e.enableZoom===!1)return;mt(a),o=n.DOLLY;break;case c.MOUSE.ROTATE:if(a.ctrlKey||a.metaKey||a.shiftKey){if(e.enablePan===!1)return;xe(a),o=n.PAN}else{if(e.enableRotate===!1)return;Oe(a),o=n.ROTATE}break;case c.MOUSE.PAN:if(a.ctrlKey||a.metaKey||a.shiftKey){if(e.enableRotate===!1)return;Oe(a),o=n.ROTATE}else{if(e.enablePan===!1)return;xe(a),o=n.PAN}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(H)}function Pt(a){if(e.enabled!==!1)switch(o){case n.ROTATE:if(e.enableRotate===!1)return;ut(a);break;case n.DOLLY:if(e.enableZoom===!1)return;ft(a);break;case n.PAN:if(e.enablePan===!1)return;ht(a);break}}function Be(a){e.enabled===!1||e.enableZoom===!1||o!==n.NONE||(a.preventDefault(),e.dispatchEvent(H),pt(a),e.dispatchEvent(ie))}function ke(a){e.enabled===!1||e.enablePan===!1||gt(a)}function St(a){switch($e(a),p.length){case 1:switch(e.touches.ONE){case c.TOUCH.ROTATE:if(e.enableRotate===!1)return;Ce(),o=n.TOUCH_ROTATE;break;case c.TOUCH.PAN:if(e.enablePan===!1)return;Te(),o=n.TOUCH_PAN;break;default:o=n.NONE}break;case 2:switch(e.touches.TWO){case c.TOUCH.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;yt(),o=n.TOUCH_DOLLY_PAN;break;case c.TOUCH.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;wt(),o=n.TOUCH_DOLLY_ROTATE;break;default:o=n.NONE}break;default:o=n.NONE}o!==n.NONE&&e.dispatchEvent(H)}function At(a){switch($e(a),o){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;ze(a),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;Ve(a),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;bt(a),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;_t(a),e.update();break;default:o=n.NONE}}function Ne(a){e.enabled!==!1&&a.preventDefault()}function Et(a){p.push(a)}function ve(a){delete z[a.pointerId];for(let h=0;h<p.length;h++)if(p[h].pointerId==a.pointerId){p.splice(h,1);return}}function $e(a){let h=z[a.pointerId];h===void 0&&(h=new c.Vector2,z[a.pointerId]=h),h.set(a.pageX,a.pageY)}function q(a){const h=a.pointerId===p[0].pointerId?p[1]:p[0];return z[h.pointerId]}e.domElement.addEventListener("contextmenu",Ne),e.domElement.addEventListener("pointerdown",Re),e.domElement.addEventListener("pointercancel",Ie),e.domElement.addEventListener("wheel",Be,{passive:!1}),this.update()}}const Ye={name:"OrbitControls",render:()=>null},se=l.defineComponent({...Ye,props:{enablePan:{type:Boolean,default:!0},enableRotate:{type:Boolean,default:!0},enableZoom:{type:Boolean,default:!0},minZoom:{default:0},maxZoom:{default:1/0},minDistance:{default:0},maxDistance:{default:1/0},minPolarAngle:{default:0},maxPolarAngle:{default:Math.PI},minAzimuthAngle:{default:1/0},maxAzimuthAngle:{default:1/0}},setup(r,{expose:i}){const t=r,e=l.ref(null);l.inject("addControls")(e);const n=l.inject("parentCamera"),o=l.inject("canvas");function s(){e.value!=null&&(e.value.enablePan=t.enablePan,e.value.enableRotate=t.enableRotate,e.value.enableZoom=t.enableZoom,e.value.minZoom=t.minZoom,e.value.maxZoom=t.maxZoom,e.value.minDistance=t.minDistance,e.value.maxDistance=t.maxDistance,e.value.minPolarAngle=t.minPolarAngle,e.value.maxPolarAngle=t.maxPolarAngle,e.value.minAzimuthAngle=t.minAzimuthAngle,e.value.maxAzimuthAngle=t.maxAzimuthAngle)}return l.watch(o,()=>{e.value=new He(n,o.value),s()}),s(),P(t,"enablePan",s),P(t,"enableRotate",s),P(t,"enableZoom",s),P(t,"minZoom",s),P(t,"maxZoom",s),P(t,"minDistance",s),P(t,"maxDistance",s),P(t,"minPolarAngle",s),P(t,"maxPolarAngle",s),P(t,"minAzimuthAngle",s),P(t,"maxAzimuthAngle",s),i({three:e.value}),{props:t,three:e,camera:n,canvas:o,applyProps:s}}}),re=l.defineComponent({__name:"Mesh",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r,e=l.inject("scene"),n=new c.BufferGeometry,o=new c.MeshBasicMaterial,s=new c.Mesh(n,o);s.castShadow=!0,s.receiveShadow=!0,e.add(s),S(t,"position",s),S(t,"rotation",s),S(t,"scale",s);function d(f){s.castShadow=f.castShadow,s.receiveShadow=f.receiveShadow}return d(t),l.watch(()=>t.castShadow,()=>d(t)),l.watch(()=>t.receiveShadow,()=>d(t)),l.provide("mesh",s),i({three:s}),(f,w)=>l.renderSlot(f.$slots,"default")}}),le=l.defineComponent({__name:"Points",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(r,{expose:i}){const t=r,e=l.inject("scene"),n=new c.BufferGeometry,o=new c.PointsMaterial({color:"red",sizeAttenuation:!1,size:2}),s=new c.Points(n,o);return e.add(s),S(t,"position",s),S(t,"rotation",s),S(t,"scale",s),l.provide("mesh",s),i({three:s}),(d,f)=>l.renderSlot(d.$slots,"default")}}),Ze=/^[og]\s*(.+)?/,Xe=/^mtllib /,Ke=/^usemtl /,qe=/^usemap /,ce=new c.Vector3,Y=new c.Vector3,de=new c.Vector3,me=new c.Vector3,D=new c.Vector3,U=new c.Color;function We(){const r={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(i,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=i,this.object.fromDeclaration=t!==!1;return}const e=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:i||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,o){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const d={index:this.materials.length,name:n||"",mtllib:Array.isArray(o)&&o.length>0?o[o.length-1]:"",smooth:s!==void 0?s.smooth:this.smooth,groupStart:s!==void 0?s.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(f){const w={index:typeof f=="number"?f:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return w.clone=this.clone.bind(w),w}};return this.materials.push(d),d},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const o=this.currentMaterial();if(o&&o.groupEnd===-1&&(o.groupEnd=this.geometry.vertices.length/3,o.groupCount=o.groupEnd-o.groupStart,o.inherited=!1),n&&this.materials.length>1)for(let s=this.materials.length-1;s>=0;s--)this.materials[s].groupCount<=0&&this.materials.splice(s,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),o}},e&&e.name&&typeof e.clone=="function"){const n=e.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(i,t){const e=parseInt(i,10);return(e>=0?e-1:e+t/3)*3},parseNormalIndex:function(i,t){const e=parseInt(i,10);return(e>=0?e-1:e+t/3)*3},parseUVIndex:function(i,t){const e=parseInt(i,10);return(e>=0?e-1:e+t/2)*2},addVertex:function(i,t,e){const n=this.vertices,o=this.object.geometry.vertices;o.push(n[i+0],n[i+1],n[i+2]),o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2])},addVertexPoint:function(i){const t=this.vertices;this.object.geometry.vertices.push(t[i+0],t[i+1],t[i+2])},addVertexLine:function(i){const t=this.vertices;this.object.geometry.vertices.push(t[i+0],t[i+1],t[i+2])},addNormal:function(i,t,e){const n=this.normals,o=this.object.geometry.normals;o.push(n[i+0],n[i+1],n[i+2]),o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2])},addFaceNormal:function(i,t,e){const n=this.vertices,o=this.object.geometry.normals;ce.fromArray(n,i),Y.fromArray(n,t),de.fromArray(n,e),D.subVectors(de,Y),me.subVectors(ce,Y),D.cross(me),D.normalize(),o.push(D.x,D.y,D.z),o.push(D.x,D.y,D.z),o.push(D.x,D.y,D.z)},addColor:function(i,t,e){const n=this.colors,o=this.object.geometry.colors;n[i]!==void 0&&o.push(n[i+0],n[i+1],n[i+2]),n[t]!==void 0&&o.push(n[t+0],n[t+1],n[t+2]),n[e]!==void 0&&o.push(n[e+0],n[e+1],n[e+2])},addUV:function(i,t,e){const n=this.uvs,o=this.object.geometry.uvs;o.push(n[i+0],n[i+1]),o.push(n[t+0],n[t+1]),o.push(n[e+0],n[e+1])},addDefaultUV:function(){const i=this.object.geometry.uvs;i.push(0,0),i.push(0,0),i.push(0,0)},addUVLine:function(i){const t=this.uvs;this.object.geometry.uvs.push(t[i+0],t[i+1])},addFace:function(i,t,e,n,o,s,d,f,w){const L=this.vertices.length;let g=this.parseVertexIndex(i,L),b=this.parseVertexIndex(t,L),u=this.parseVertexIndex(e,L);if(this.addVertex(g,b,u),this.addColor(g,b,u),d!==void 0&&d!==""){const m=this.normals.length;g=this.parseNormalIndex(d,m),b=this.parseNormalIndex(f,m),u=this.parseNormalIndex(w,m),this.addNormal(g,b,u)}else this.addFaceNormal(g,b,u);if(n!==void 0&&n!==""){const m=this.uvs.length;g=this.parseUVIndex(n,m),b=this.parseUVIndex(o,m),u=this.parseUVIndex(s,m),this.addUV(g,b,u),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(i){this.object.geometry.type="Points";const t=this.vertices.length;for(let e=0,n=i.length;e<n;e++){const o=this.parseVertexIndex(i[e],t);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(i,t){this.object.geometry.type="Line";const e=this.vertices.length,n=this.uvs.length;for(let o=0,s=i.length;o<s;o++)this.addVertexLine(this.parseVertexIndex(i[o],e));for(let o=0,s=t.length;o<s;o++)this.addUVLine(this.parseUVIndex(t[o],n))}};return r.startObject("",!1),r}class Je extends c.Loader{constructor(i){super(i),this.materials=null}load(i,t,e,n){const o=this,s=new c.FileLoader(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(i,function(d){try{t(o.parse(d))}catch(f){n?n(f):console.error(f),o.manager.itemError(i)}},e,n)}setMaterials(i){return this.materials=i,this}parse(i){const t=new We;i.indexOf(`\r
`)!==-1&&(i=i.replace(/\r\n/g,`
`)),i.indexOf(`\\
`)!==-1&&(i=i.replace(/\\\n/g,""));const e=i.split(`
`);let n="",o="",s=0,d=[];const f=typeof"".trimLeft=="function";for(let g=0,b=e.length;g<b;g++)if(n=e[g],n=f?n.trimLeft():n.trim(),s=n.length,s!==0&&(o=n.charAt(0),o!=="#"))if(o==="v"){const u=n.split(/\s+/);switch(u[0]){case"v":t.vertices.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3])),u.length>=7?(U.setRGB(parseFloat(u[4]),parseFloat(u[5]),parseFloat(u[6])).convertSRGBToLinear(),t.colors.push(U.r,U.g,U.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(u[1]),parseFloat(u[2]),parseFloat(u[3]));break;case"vt":t.uvs.push(parseFloat(u[1]),parseFloat(u[2]));break}}else if(o==="f"){const m=n.slice(1).trim().split(/\s+/),_=[];for(let O=0,C=m.length;O<C;O++){const A=m[O];if(A.length>0){const x=A.split("/");_.push(x)}}const y=_[0];for(let O=1,C=_.length-1;O<C;O++){const A=_[O],x=_[O+1];t.addFace(y[0],A[0],x[0],y[1],A[1],x[1],y[2],A[2],x[2])}}else if(o==="l"){const u=n.substring(1).trim().split(" ");let m=[];const _=[];if(n.indexOf("/")===-1)m=u;else for(let y=0,O=u.length;y<O;y++){const C=u[y].split("/");C[0]!==""&&m.push(C[0]),C[1]!==""&&_.push(C[1])}t.addLineGeometry(m,_)}else if(o==="p"){const m=n.slice(1).trim().split(" ");t.addPointGeometry(m)}else if((d=Ze.exec(n))!==null){const u=(" "+d[0].slice(1).trim()).slice(1);t.startObject(u)}else if(Ke.test(n))t.object.startMaterial(n.substring(7).trim(),t.materialLibraries);else if(Xe.test(n))t.materialLibraries.push(n.substring(7).trim());else if(qe.test(n))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(o==="s"){if(d=n.split(" "),d.length>1){const m=d[1].trim().toLowerCase();t.object.smooth=m!=="0"&&m!=="off"}else t.object.smooth=!0;const u=t.object.currentMaterial();u&&(u.smooth=t.object.smooth)}else{if(n==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+n+'"')}t.finalize();const w=new c.Group;if(w.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let g=0,b=t.objects.length;g<b;g++){const u=t.objects[g],m=u.geometry,_=u.materials,y=m.type==="Line",O=m.type==="Points";let C=!1;if(m.vertices.length===0)continue;const A=new c.BufferGeometry;A.setAttribute("position",new c.Float32BufferAttribute(m.vertices,3)),m.normals.length>0&&A.setAttribute("normal",new c.Float32BufferAttribute(m.normals,3)),m.colors.length>0&&(C=!0,A.setAttribute("color",new c.Float32BufferAttribute(m.colors,3))),m.hasUVIndices===!0&&A.setAttribute("uv",new c.Float32BufferAttribute(m.uvs,2));const x=[];for(let z=0,F=_.length;z<F;z++){const V=_[z],N=V.name+"_"+V.smooth+"_"+C;let E=t.materials[N];if(this.materials!==null){if(E=this.materials.create(V.name),y&&E&&!(E instanceof c.LineBasicMaterial)){const R=new c.LineBasicMaterial;c.Material.prototype.copy.call(R,E),R.color.copy(E.color),E=R}else if(O&&E&&!(E instanceof c.PointsMaterial)){const R=new c.PointsMaterial({size:10,sizeAttenuation:!1});c.Material.prototype.copy.call(R,E),R.color.copy(E.color),R.map=E.map,E=R}}E===void 0&&(y?E=new c.LineBasicMaterial:O?E=new c.PointsMaterial({size:1,sizeAttenuation:!1}):E=new c.MeshPhongMaterial,E.name=V.name,E.flatShading=!V.smooth,E.vertexColors=C,t.materials[N]=E),x.push(E)}let p;if(x.length>1){for(let z=0,F=_.length;z<F;z++){const V=_[z];A.addGroup(V.groupStart,V.groupCount,z)}y?p=new c.LineSegments(A,x):O?p=new c.Points(A,x):p=new c.Mesh(A,x)}else y?p=new c.LineSegments(A,x[0]):O?p=new c.Points(A,x[0]):p=new c.Mesh(A,x[0]);p.name=u.name,w.add(p)}else if(t.vertices.length>0){const g=new c.PointsMaterial({size:1,sizeAttenuation:!1}),b=new c.BufferGeometry;b.setAttribute("position",new c.Float32BufferAttribute(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(b.setAttribute("color",new c.Float32BufferAttribute(t.colors,3)),g.vertexColors=!0);const u=new c.Points(b,g);w.add(u)}return w}}const ue=l.defineComponent({__name:"OBJLoader",props:{url:null,position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]},castShadow:{type:Boolean,default:!1},receiveShadow:{type:Boolean,default:!1}},emits:["load","progress","error"],setup(r,{expose:i,emit:t}){const e=r,n=new Je,o=l.inject("scene"),s=new c.Group;s.castShadow=!0,s.receiveShadow=!0,o.add(s),S(e,"position",s),S(e,"rotation",s),S(e,"scale",s);function d(){n.load(e.url,function(f){for(const w of f.children)s.children.push(w),w.material=s.material,S(e,"position",s,!1),S(e,"rotation",s,!1),S(e,"scale",s,!1);t("load",f)},function(f){t("progress",f)},function(f){t("error",f)})}return d(),l.watch(()=>e.url,()=>d()),l.provide("mesh",s),i({three:s}),(f,w)=>l.renderSlot(f.$slots,"default")}}),fe=l.defineComponent({__name:"AxesHelper",props:{size:{default:1},position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(r,{expose:i}){const t=r,e=l.inject("scene"),n=new c.AxesHelper(t.size);return e.add(n),S(t,"position",n),S(t,"rotation",n),S(t,"scale",n),l.provide("mesh",n),i({three:n}),(o,s)=>l.renderSlot(o.$slots,"default")}}),Qe={name:"BoxGeometry",render:()=>null},he=l.defineComponent({...Qe,props:{width:{default:1},height:{default:1},depth:{default:1},widthSegments:{default:1},heightSegments:{default:1},depthSegments:{default:1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh");function n(d,f,w,L,g,b){return new c.BoxGeometry(d,f,w,L,g,b)}const o=l.ref(n(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments));e.geometry=o.value;function s(){e.geometry.dispose(),e.geometry=n(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments),o.value=e.geometry}return P(t,"width",s),P(t,"height",s),P(t,"depth",s),P(t,"widthSegments",s),P(t,"heightSegments",s),P(t,"depthSegments",s),i({three:o}),{props:t,mesh:e,makeBox:n,three:o,redoGeometry:s}}}),et={name:"BufferGeometry",render:()=>null},pe=l.defineComponent({...et,props:{vertices:{default:()=>[]},faces:{default:()=>[]}},setup(r,{expose:i}){const t=r,e=l.inject("mesh");function n(d,f){const w=new c.BufferGeometry,L=new Float32Array(d.length);for(let g=0;g<d.length;g++)L[g]=d[g];return w.setAttribute("position",new c.BufferAttribute(L,3)),w}const o=l.ref(n(t.vertices,t.faces));e.geometry=o.value;function s(d){e.geometry.dispose(),e.geometry=n(d),e.geometry.computeVertexNormals(),o.value=e.geometry}return l.watch(()=>t.vertices,d=>{s(d)},{deep:!0,immediate:!0}),i({three:o}),{props:t,mesh:e,makeGeometry:n,three:o,redoGeometry:s}}}),tt={name:"PlaneGeometry",render:()=>null},ge=l.defineComponent({...tt,props:{width:{default:1},height:{default:1},widthSegments:{default:1},heightSegments:{default:1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh");function n(d,f,w,L){return new c.PlaneGeometry(d,f,w,L)}const o=l.ref(n(t.width,t.height,t.widthSegments,t.heightSegments));e.geometry=o.value;function s(){e.geometry.dispose(),e.geometry=n(t.width,t.height,t.widthSegments,t.heightSegments),o.value=e.geometry}return P(t,"width",s),P(t,"height",s),P(t,"widthSegments",s),P(t,"heightSegments",s),i({three:o}),{props:t,mesh:e,makePlane:n,three:o,redoGeometry:s}}}),nt={name:"SphereGeometry",render:()=>null},ye=l.defineComponent({...nt,props:{radius:{default:1},widthSegments:{default:8},heightSegments:{default:6},phiStart:{default:0},phiLength:{default:2*Math.PI},thetaStart:{default:0},thetaLength:{default:Math.PI}},setup(r,{expose:i}){const t=r,e=l.inject("mesh");function n(d,f,w,L,g,b,u){return new c.SphereGeometry(d,f,w,L,g,b,u)}const o=l.ref(n(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength));e.geometry=o.value;function s(){e.geometry.dispose(),e.geometry=n(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength),o.value=e.geometry}return P(t,"radius",s),P(t,"widthSegments",s),P(t,"heightSegments",s),P(t,"phiStart",s),P(t,"phiLength",s),P(t,"thetaStart",s),P(t,"thetaLength",s),i({three:o}),{props:t,mesh:e,makeSphere:n,three:o,redoGeometry:s}}}),ot={name:"MeshBasicMaterial"},we=l.defineComponent({...ot,props:{color:null,side:{default:c.FrontSide},opacity:{default:1},transparent:{type:Boolean,default:!1},vertexColors:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh"),n=new c.MeshBasicMaterial;return e.material=n,l.watch(()=>t.color,()=>{t.color!==void 0&&(n.color=new c.Color(t.color))},{immediate:!0}),l.watch(()=>t.side,()=>{n.side=t.side},{immediate:!0}),l.watch(()=>t.opacity,()=>{n.opacity=t.opacity},{immediate:!0}),l.watch(()=>t.transparent,()=>{n.transparent=t.transparent},{immediate:!0}),l.watch(()=>t.vertexColors,()=>{n.vertexColors=t.vertexColors},{immediate:!0}),l.provide("material",n),i({three:n}),(o,s)=>l.renderSlot(o.$slots,"default")}}),at={name:"MeshLambertMaterial"},be=l.defineComponent({...at,props:{color:{default:16777215},side:{default:c.FrontSide},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh"),n=new c.MeshLambertMaterial;e.material=n;function o(s){s.color&&(n.color=new c.Color(s.color)),s.side&&(n.side=s.side)}return o(t),l.watch(()=>t.color,()=>o(t)),l.watch(()=>t.side,()=>o(t)),l.watch(()=>t.opacity,()=>{n.opacity=t.opacity},{immediate:!0}),l.watch(()=>t.transparent,()=>{n.transparent=t.transparent},{immediate:!0}),l.provide("material",n),i({three:n}),(s,d)=>l.renderSlot(s.$slots,"default")}}),it={name:"PointsMaterial",render:()=>null},_e=l.defineComponent({...it,props:{color:{default:16777215},sizeAttenuation:{type:Boolean,default:!0},size:{default:1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh"),n=new c.PointsMaterial({color:t.color,sizeAttenuation:t.sizeAttenuation,size:t.size});e.material=n;function o(s){s.color&&(n.color=new c.Color(s.color)),s.size&&(n.size=s.size),s.sizeAttenuation!==void 0&&(n.sizeAttenuation=s.sizeAttenuation)}return o(t),l.watch(()=>t.color,()=>o(t)),l.watch(()=>t.size,()=>o(t)),l.watch(()=>t.sizeAttenuation,()=>o(t)),l.provide("material",n),i({three:n}),{props:t,mesh:e,three:n,applyProps:o}}}),st={name:"MeshNormalMaterial"},Me=l.defineComponent({...st,props:{side:{default:c.FrontSide},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r,e=l.inject("mesh"),n=new c.MeshNormalMaterial;return e.material=n,l.watch(()=>t.side,()=>{n.side=t.side},{immediate:!0}),l.watch(()=>t.opacity,()=>{n.opacity=t.opacity},{immediate:!0}),l.watch(()=>t.transparent,()=>{n.transparent=t.transparent},{immediate:!0}),l.provide("material",n),i({three:n}),(o,s)=>l.renderSlot(o.$slots,"default")}}),rt={name:"AmbientLight",render:()=>null},Pe=l.defineComponent({...rt,props:{color:{default:16777215},intensity:{default:1}},setup(r,{expose:i}){const t=r,e=l.inject("scene"),n=new c.AmbientLight;e.add(n);function o(s){n.color=new c.Color(s.color),n.intensity=s.intensity}return o(t),l.watch(()=>t.color,()=>o(t)),l.watch(()=>t.intensity,()=>o(t)),i({three:n}),{props:t,scene:e,three:n,applyProps:o}}}),lt={name:"PointLight",render:()=>null},Se=l.defineComponent({...lt,props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]},color:{default:16777215},intensity:{default:1},castShadow:{type:Boolean,default:!1}},setup(r,{expose:i}){const t=r,e=l.inject("scene"),n=new c.PointLight;e.add(n),S(t,"position",n),S(t,"rotation",n),S(t,"scale",n);function o(s){n.color=new c.Color(s.color),n.intensity=s.intensity,n.castShadow=s.castShadow}return o(t),l.watch(()=>t.color,()=>o(t)),l.watch(()=>t.intensity,()=>o(t)),l.watch(()=>t.castShadow,()=>o(t)),i({three:n}),{props:t,scene:e,three:n,applyProps:o}}}),ct={name:"TextureLoader",render:()=>null},Ae=l.defineComponent({...ct,props:{url:null},setup(r,{expose:i}){const t=r,e=l.inject("material"),n=l.ref(new c.Texture);function o(s){"map"in e&&(e.map=new c.TextureLoader().load(s.url))}return o(t),l.watch(()=>t.url,()=>o(t)),i({three:n}),{props:t,material:e,three:n,applyProps:o}}});function dt(r){r.component("Renderer",ee),r.component("Scene",te),r.component("PerspectiveCamera",ne),r.component("OrthographicCamera",oe),r.component("OrbitControls",se),r.component("Mesh",re),r.component("Points",le),r.component("OBJLoader",ue),r.component("AxesHelper",fe),r.component("BoxGeometry",he),r.component("BufferGeometry",pe),r.component("PlaneGeometry",ge),r.component("SphereGeometry",ye),r.component("MeshBasicMaterial",we),r.component("MeshLambertMaterial",be),r.component("PointsMaterial",_e),r.component("MeshNormalMaterial",Me),r.component("AmbientLight",Pe),r.component("PointLight",Se),r.component("TextureLoader",Ae)}M.AmbientLight=Pe,M.AxesHelper=fe,M.BoxGeometry=he,M.BufferGeometry=pe,M.Mesh=re,M.MeshBasicMaterial=we,M.MeshLambertMaterial=be,M.MeshNormalMaterial=Me,M.OBJLoader=ue,M.OrbitControls=se,M.OrthographicCamera=oe,M.PerspectiveCamera=ne,M.PlaneGeometry=ge,M.PointLight=Se,M.Points=le,M.PointsMaterial=_e,M.Renderer=ee,M.Scene=te,M.SphereGeometry=ye,M.TextureLoader=Ae,M.install=dt,Object.defineProperty(M,Symbol.toStringTag,{value:"Module"})});
