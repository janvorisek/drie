(function(P,d){typeof exports=="object"&&typeof module<"u"?d(exports,require("vue"),require("three")):typeof define=="function"&&define.amd?define(["exports","vue","three"],d):(P=typeof globalThis<"u"?globalThis:P||self,d(P["@janvorisek/drie"]={},P.Vue,P.three))})(this,function(P,d,a){"use strict";const tt=l=>l===void 0?new a.Vector3(0,0,0):"x"in l?new a.Vector3(l.x,l.y,l.z):new a.Vector3(l[0],l[1],l[2]),nt=l=>l===void 0?new a.Vector2(0,0):"x"in l?new a.Vector2(l.x,l.y):new a.Vector2(l[0],l[1]),st=(l,s,t)=>{t[l].isVector3?t[l].set(s.x,s.y,s.z):"isEuler"in t[l]&&t[l].setFromVector3(s)},C=(l,s,t,e=!0)=>{if(t!==null){if(l[s]!==void 0){const n=tt(l[s]);st(s,n,t)}e&&d.watch(()=>l[s],()=>{if(l[s]!==void 0){const n=tt(l[s]);st(s,n,t)}})}},ot=(l,s,t)=>{t[l].isVector2&&t[l].set(s.x,s.y)},it=(l,s,t,e=!0)=>{if(t!==null){if(l[s]!==void 0){const n=nt(l[s]);ot(s,n,t)}e&&d.watch(()=>l[s],()=>{if(l[s]!==void 0){const n=nt(l[s]);ot(s,n,t)}})}},b=(l,s,t)=>{d.watch(()=>l[s],()=>{t()})};function te(l,s){s.hasAttribute("position")&&(l.setAttribute("position",s.getAttribute("position")),l.attributes.position.needsUpdate=!0),s.hasAttribute("normal")&&(l.setAttribute("normal",s.getAttribute("normal")),l.attributes.normal.needsUpdate=!0),s.hasAttribute("uv")&&(l.setAttribute("uv",s.getAttribute("uv")),l.attributes.uv.needsUpdate=!0),l.setIndex(s.getIndex())}function ie(l){if(l.children.length>0)for(let s=l.children.length-1;s>=0;s--)ie(l.children[s]);if(l.geometry&&l.geometry.dispose(),l.material)if(l.material.length)for(let s=0;s<l.material.length;++s)l.material[s].map&&l.material[s].map.dispose(),l.material[s].lightMap&&l.material[s].lightMap.dispose(),l.material[s].bumpMap&&l.material[s].bumpMap.dispose(),l.material[s].normalMap&&l.material[s].normalMap.dispose(),l.material[s].specularMap&&l.material[s].specularMap.dispose(),l.material[s].envMap&&l.material[s].envMap.dispose(),l.material[s].dispose();else l.material.map&&l.material.map.dispose(),l.material.lightMap&&l.material.lightMap.dispose(),l.material.bumpMap&&l.material.bumpMap.dispose(),l.material.normalMap&&l.material.normalMap.dispose(),l.material.specularMap&&l.material.specularMap.dispose(),l.material.envMap&&l.material.envMap.dispose(),l.material.dispose();return l.removeFromParent(),!0}function ae(l){const s=d.inject("scene"),t=d.inject("parent",void 0);d.onMounted(()=>{t?t.add(l):s.add(l)}),d.onUnmounted(()=>{t?t.remove(l):s.remove(l)})}function Fe(l,s,t){const e=d.inject("camera"),n=d.inject("canvas");d.inject("scene");const i=u=>{const f=new a.Raycaster,p=at(u);f.setFromCamera(p,e.value);const m=f.intersectObjects(l);m.length>0&&t("click",m,p)};let o=!1,r=[];const c=u=>{const f=new a.Raycaster,p=at(u);f.setFromCamera(p,e.value);const m=f.intersectObjects(l);m.length>0?(r=m,o===!1&&t("mouseenter",m,p),o=!0,t("mousemove",m,p)):(o&&t("mouseleave",r,p),o=!1,r=[])};d.onMounted(()=>{if(s.enableRaycasting){if((n==null?void 0:n.value)==null)return;n==null||n.value.addEventListener("click",i),n==null||n.value.addEventListener("mousemove",c)}}),d.onUnmounted(()=>{if(s.enableRaycasting){if((n==null?void 0:n.value)==null)return;n==null||n.value.removeEventListener("click",i),n==null||n.value.removeEventListener("mousemove",c)}}),d.watch(()=>s.enableRaycasting,u=>{u?(n==null||n.value.addEventListener("click",i),n==null||n.value.addEventListener("mousemove",c)):(n==null||n.value.removeEventListener("click",i),n==null||n.value.removeEventListener("mousemove",c))})}function at(l){const s=new a.Vector2,t=l.currentTarget.getBoundingClientRect();return s.x=(l.clientX-t.left)/t.width*2-1,s.y=-((l.clientY-t.top)/t.height)*2+1,s}const rt=d.defineComponent({__name:"Renderer",props:{alpha:{type:Boolean,default:!1},antialias:{type:Boolean,default:!1},autoResize:{type:Boolean,default:!0},camera:null,height:{default:0},frameLimit:{default:60},onBeforeRender:{type:Function,default:()=>{}},shadowMapEnabled:{type:Boolean,default:!1},width:{default:0}},setup(l,{expose:s}){const t=l;let e=d.ref(null);const n=[],i=d.reactive([]),o=d.reactive([]);let r=d.ref(null);const c=d.ref([]),u=d.ref([]),f=d.ref();d.provide("canvas",f);let p=!0,m=Date.now(),h=1e3/t.frameLimit;d.watch(()=>t.camera,y=>w(y));const w=y=>{if(y){const S=c.value.find(T=>T.name===y);S===void 0&&(r.value=null),r.value=S}else r.value=c.value[0]};function _(){e.value!==null&&(e.value.shadowMap.enabled=t.shadowMapEnabled,h=1e3/t.frameLimit,t.autoResize||e.value.setSize(t.width,t.height))}d.onMounted(()=>{e.value=new a.WebGLRenderer({canvas:f.value,antialias:t.antialias,alpha:t.alpha}),e.value.setSize(1,1),_(),w(t.camera),new ResizeObserver(S=>{S.forEach(T=>{e.value&&t.autoResize&&e.value.setSize(T.contentRect.width,T.contentRect.height)})}).observe(f.value.parentElement),E()}),d.onUnmounted(()=>{for(let y of n)ie(y)});function E(){if(requestAnimationFrame(E),e.value===null)return;const y=Date.now(),S=y-m;if(!(h>-1&&S<h)){if(m=y-S%h,t.onBeforeRender&&t.onBeforeRender(),u.value.length>0&&r.value)for(const T of u.value)T.value!==null&&(T.value.object.uuid===r.value.uuid?(T.value.enabled=p,T.value.update()):T.value.enabled=!1);if(r.value&&e)for(const T of n)e.value.render(T,r.value)}}return _(),d.watch(()=>t.shadowMapEnabled,()=>_()),d.watch(()=>t.frameLimit,()=>_()),d.watch(()=>t.width,()=>_()),d.watch(()=>t.height,()=>_()),d.provide("addCamera",y=>c.value.push(y)),d.provide("addScene",y=>n.push(y)),d.provide("addGeometry",y=>i.push(y)),d.provide("getGeometry",y=>i.find(S=>S.name===y)),d.provide("addMaterial",y=>o.push(y)),d.provide("getMaterial",y=>o.find(S=>S.name===y)),d.provide("addControls",y=>u.value.push(y)),d.provide("enableAllControls",()=>{p=!0}),d.provide("disableAllControls",()=>{p=!1}),d.provide("camera",r),s({three:e}),(y,S)=>(d.openBlock(),d.createElementBlock(d.Fragment,null,[d.createElementVNode("canvas",{ref_key:"canvas",ref:f},null,512),d.renderSlot(y.$slots,"default")],64))}}),ct=d.defineComponent({__name:"Scene",props:{background:{default:16777215}},setup(l,{expose:s}){const t=l,e=new a.Scene;d.provide("scene",e),d.inject("addScene")(e);function n(i){i.background&&(e.background=new a.Color(i.background))}return n(t),d.watch(()=>t.background,()=>n(t)),s({three:e}),(i,o)=>d.renderSlot(i.$slots,"default")}}),bn={name:"PerspectiveCamera"},lt=d.defineComponent({...bn,props:{aspect:{default:1},autoResize:{type:Boolean,default:!0},far:{default:2e3},lookAt:{default:()=>[0,0,0]},name:{default:""},near:{default:.1},position:{default:()=>[0,0,0]},up:{default:()=>[0,1,0]}},setup(l,{expose:s}){const t=l,e=new a.PerspectiveCamera(75,window.innerWidth/window.innerHeight*1e3,.1,1e3);d.inject("addCamera")(e);const n=d.inject("canvas");d.watch(n,()=>{new ResizeObserver(r=>{r.forEach(c=>{t.autoResize&&(e.aspect=c.contentRect.width/c.contentRect.height,e.updateProjectionMatrix())})}).observe(n.value)}),C(t,"position",e),C(t,"up",e),C(t,"lookAt",e);function i(){e.name=t.name,t.autoResize||(e.aspect=t.aspect),e.near=t.near,e.far=t.far,e.updateProjectionMatrix()}return i(),b(t,"name",i),b(t,"aspect",i),b(t,"near",i),b(t,"far",i),d.provide("parentCamera",e),s({three:e}),(o,r)=>d.renderSlot(o.$slots,"default")}}),_n={name:"OrthographicCamera"},ut=d.defineComponent({..._n,props:{far:{default:2e3},lookAt:{default:()=>[0,0,0]},name:{default:""},near:{default:.1},position:{default:()=>[0,0,0]},up:{default:()=>[0,1,0]}},setup(l,{expose:s}){const t=l,e=new a.OrthographicCamera(-10,10,10,-10,.1,1e3);e.lookAt(0,0,0),e.updateProjectionMatrix(),d.inject("addCamera")(e);const n=d.inject("canvas");d.watch(n,()=>{new ResizeObserver(r=>{r.forEach(c=>{const u=c.contentRect.width/c.contentRect.height;e.left=e.bottom*u,e.right=e.top*u,e.updateProjectionMatrix()})}).observe(n.value)}),C(t,"position",e),C(t,"up",e),C(t,"lookAt",e);function i(){e.name=t.name,e.near=t.near,e.far=t.far,e.updateProjectionMatrix()}return i(),b(t,"name",i),b(t,"near",i),b(t,"far",i),d.provide("parentCamera",e),s({three:e}),(o,r)=>d.renderSlot(o.$slots,"default")}}),dt={type:"change"},Be={type:"start"},pt={type:"end"};class En extends a.EventDispatcher{constructor(s,t){super(),t===void 0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),this.object=s,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new a.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:a.MOUSE.ROTATE,MIDDLE:a.MOUSE.DOLLY,RIGHT:a.MOUSE.PAN},this.touches={ONE:a.TOUCH.ROTATE,TWO:a.TOUCH.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return r.phi},this.getAzimuthalAngle=function(){return r.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(g){g.addEventListener("keydown",hn),this._domElementKeyEvents=g},this.saveState=function(){e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=function(){e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(dt),e.update(),i=n.NONE},this.update=function(){const g=new a.Vector3,L=new a.Quaternion().setFromUnitVectors(s.up,new a.Vector3(0,1,0)),X=L.clone().invert(),Z=new a.Vector3,ne=new a.Quaternion,_e=2*Math.PI;return function(){const Mn=e.object.position;g.copy(Mn).sub(e.target),g.applyQuaternion(L),r.setFromVector3(g),e.autoRotate&&i===n.NONE&&V(j()),e.enableDamping?(r.theta+=c.theta*e.dampingFactor,r.phi+=c.phi*e.dampingFactor):(r.theta+=c.theta,r.phi+=c.phi);let le=e.minAzimuthAngle,ue=e.maxAzimuthAngle;return isFinite(le)&&isFinite(ue)&&(le<-Math.PI?le+=_e:le>Math.PI&&(le-=_e),ue<-Math.PI?ue+=_e:ue>Math.PI&&(ue-=_e),le<=ue?r.theta=Math.max(le,Math.min(ue,r.theta)):r.theta=r.theta>(le+ue)/2?Math.max(le,r.theta):Math.min(ue,r.theta)),r.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,r.phi)),r.makeSafe(),r.radius*=u,r.radius=Math.max(e.minDistance,Math.min(e.maxDistance,r.radius)),e.enableDamping===!0?e.target.addScaledVector(f,e.dampingFactor):e.target.add(f),g.setFromSpherical(r),g.applyQuaternion(X),Mn.copy(e.target).add(g),e.object.lookAt(e.target),e.enableDamping===!0?(c.theta*=1-e.dampingFactor,c.phi*=1-e.dampingFactor,f.multiplyScalar(1-e.dampingFactor)):(c.set(0,0,0),f.set(0,0,0)),u=1,p||Z.distanceToSquared(e.object.position)>o||8*(1-ne.dot(e.object.quaternion))>o?(e.dispatchEvent(dt),Z.copy(e.object.position),ne.copy(e.object.quaternion),p=!1,!0):!1}}(),this.dispose=function(){e.domElement.removeEventListener("contextmenu",gn),e.domElement.removeEventListener("pointerdown",Me),e.domElement.removeEventListener("pointercancel",fn),e.domElement.removeEventListener("wheel",mn),e.domElement.removeEventListener("pointermove",We),e.domElement.removeEventListener("pointerup",Je),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",hn)};const e=this,n={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let i=n.NONE;const o=1e-6,r=new a.Spherical,c=new a.Spherical;let u=1;const f=new a.Vector3;let p=!1;const m=new a.Vector2,h=new a.Vector2,w=new a.Vector2,_=new a.Vector2,E=new a.Vector2,y=new a.Vector2,S=new a.Vector2,T=new a.Vector2,A=new a.Vector2,x=[],v={};function j(){return 2*Math.PI/60/60*e.autoRotateSpeed}function G(){return Math.pow(.95,e.zoomSpeed)}function V(g){c.theta-=g}function O(g){c.phi-=g}const B=function(){const g=new a.Vector3;return function(X,Z){g.setFromMatrixColumn(Z,0),g.multiplyScalar(-X),f.add(g)}}(),Q=function(){const g=new a.Vector3;return function(X,Z){e.screenSpacePanning===!0?g.setFromMatrixColumn(Z,1):(g.setFromMatrixColumn(Z,0),g.crossVectors(e.object.up,g)),g.multiplyScalar(X),f.add(g)}}(),F=function(){const g=new a.Vector3;return function(X,Z){const ne=e.domElement;if(e.object.isPerspectiveCamera){const _e=e.object.position;g.copy(_e).sub(e.target);let ke=g.length();ke*=Math.tan(e.object.fov/2*Math.PI/180),B(2*X*ke/ne.clientHeight,e.object.matrix),Q(2*Z*ke/ne.clientHeight,e.object.matrix)}else e.object.isOrthographicCamera?(B(X*(e.object.right-e.object.left)/e.object.zoom/ne.clientWidth,e.object.matrix),Q(Z*(e.object.top-e.object.bottom)/e.object.zoom/ne.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}}();function H(g){e.object.isPerspectiveCamera?u/=g:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*g)),e.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function D(g){e.object.isPerspectiveCamera?u*=g:e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/g)),e.object.updateProjectionMatrix(),p=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function J(g){m.set(g.clientX,g.clientY)}function Y(g){S.set(g.clientX,g.clientY)}function q(g){_.set(g.clientX,g.clientY)}function z(g){h.set(g.clientX,g.clientY),w.subVectors(h,m).multiplyScalar(e.rotateSpeed);const L=e.domElement;V(2*Math.PI*w.x/L.clientHeight),O(2*Math.PI*w.y/L.clientHeight),m.copy(h),e.update()}function fe(g){T.set(g.clientX,g.clientY),A.subVectors(T,S),A.y>0?H(G()):A.y<0&&D(G()),S.copy(T),e.update()}function me(g){E.set(g.clientX,g.clientY),y.subVectors(E,_).multiplyScalar(e.panSpeed),F(y.x,y.y),_.copy(E),e.update()}function ce(g){g.deltaY<0?D(G()):g.deltaY>0&&H(G()),e.update()}function Re(g){let L=!1;switch(g.code){case e.keys.UP:F(0,e.keyPanSpeed),L=!0;break;case e.keys.BOTTOM:F(0,-e.keyPanSpeed),L=!0;break;case e.keys.LEFT:F(e.keyPanSpeed,0),L=!0;break;case e.keys.RIGHT:F(-e.keyPanSpeed,0),L=!0;break}L&&(g.preventDefault(),e.update())}function he(){if(x.length===1)m.set(x[0].pageX,x[0].pageY);else{const g=.5*(x[0].pageX+x[1].pageX),L=.5*(x[0].pageY+x[1].pageY);m.set(g,L)}}function Ce(){if(x.length===1)_.set(x[0].pageX,x[0].pageY);else{const g=.5*(x[0].pageX+x[1].pageX),L=.5*(x[0].pageY+x[1].pageY);_.set(g,L)}}function De(){const g=x[0].pageX-x[1].pageX,L=x[0].pageY-x[1].pageY,X=Math.sqrt(g*g+L*L);S.set(0,X)}function M(){e.enableZoom&&De(),e.enablePan&&Ce()}function R(){e.enableZoom&&De(),e.enableRotate&&he()}function U(g){if(x.length==1)h.set(g.pageX,g.pageY);else{const X=et(g),Z=.5*(g.pageX+X.x),ne=.5*(g.pageY+X.y);h.set(Z,ne)}w.subVectors(h,m).multiplyScalar(e.rotateSpeed);const L=e.domElement;V(2*Math.PI*w.x/L.clientHeight),O(2*Math.PI*w.y/L.clientHeight),m.copy(h)}function $(g){if(x.length===1)E.set(g.pageX,g.pageY);else{const L=et(g),X=.5*(g.pageX+L.x),Z=.5*(g.pageY+L.y);E.set(X,Z)}y.subVectors(E,_).multiplyScalar(e.panSpeed),F(y.x,y.y),_.copy(E)}function ee(g){const L=et(g),X=g.pageX-L.x,Z=g.pageY-L.y,ne=Math.sqrt(X*X+Z*Z);T.set(0,ne),A.set(0,Math.pow(T.y/S.y,e.zoomSpeed)),H(A.y),S.copy(T)}function oe(g){e.enableZoom&&ee(g),e.enablePan&&$(g)}function pn(g){e.enableZoom&&ee(g),e.enableRotate&&U(g)}function Me(g){e.enabled!==!1&&(x.length===0&&(e.domElement.setPointerCapture(g.pointerId),e.domElement.addEventListener("pointermove",We),e.domElement.addEventListener("pointerup",Je)),Us(g),g.pointerType==="touch"?Bs(g):ks(g))}function We(g){e.enabled!==!1&&(g.pointerType==="touch"?Hs(g):Fs(g))}function Je(g){yn(g),x.length===0&&(e.domElement.releasePointerCapture(g.pointerId),e.domElement.removeEventListener("pointermove",We),e.domElement.removeEventListener("pointerup",Je)),e.dispatchEvent(pt),i=n.NONE}function fn(g){yn(g)}function ks(g){let L;switch(g.button){case 0:L=e.mouseButtons.LEFT;break;case 1:L=e.mouseButtons.MIDDLE;break;case 2:L=e.mouseButtons.RIGHT;break;default:L=-1}switch(L){case a.MOUSE.DOLLY:if(e.enableZoom===!1)return;Y(g),i=n.DOLLY;break;case a.MOUSE.ROTATE:if(g.ctrlKey||g.metaKey||g.shiftKey){if(e.enablePan===!1)return;q(g),i=n.PAN}else{if(e.enableRotate===!1)return;J(g),i=n.ROTATE}break;case a.MOUSE.PAN:if(g.ctrlKey||g.metaKey||g.shiftKey){if(e.enableRotate===!1)return;J(g),i=n.ROTATE}else{if(e.enablePan===!1)return;q(g),i=n.PAN}break;default:i=n.NONE}i!==n.NONE&&e.dispatchEvent(Be)}function Fs(g){if(e.enabled!==!1)switch(i){case n.ROTATE:if(e.enableRotate===!1)return;z(g);break;case n.DOLLY:if(e.enableZoom===!1)return;fe(g);break;case n.PAN:if(e.enablePan===!1)return;me(g);break}}function mn(g){e.enabled===!1||e.enableZoom===!1||i!==n.NONE||(g.preventDefault(),e.dispatchEvent(Be),ce(g),e.dispatchEvent(pt))}function hn(g){e.enabled===!1||e.enablePan===!1||Re(g)}function Bs(g){switch(wn(g),x.length){case 1:switch(e.touches.ONE){case a.TOUCH.ROTATE:if(e.enableRotate===!1)return;he(),i=n.TOUCH_ROTATE;break;case a.TOUCH.PAN:if(e.enablePan===!1)return;Ce(),i=n.TOUCH_PAN;break;default:i=n.NONE}break;case 2:switch(e.touches.TWO){case a.TOUCH.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;M(),i=n.TOUCH_DOLLY_PAN;break;case a.TOUCH.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;R(),i=n.TOUCH_DOLLY_ROTATE;break;default:i=n.NONE}break;default:i=n.NONE}i!==n.NONE&&e.dispatchEvent(Be)}function Hs(g){switch(wn(g),i){case n.TOUCH_ROTATE:if(e.enableRotate===!1)return;U(g),e.update();break;case n.TOUCH_PAN:if(e.enablePan===!1)return;$(g),e.update();break;case n.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;oe(g),e.update();break;case n.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;pn(g),e.update();break;default:i=n.NONE}}function gn(g){e.enabled!==!1&&g.preventDefault()}function Us(g){x.push(g)}function yn(g){delete v[g.pointerId];for(let L=0;L<x.length;L++)if(x[L].pointerId==g.pointerId){x.splice(L,1);return}}function wn(g){let L=v[g.pointerId];L===void 0&&(L=new a.Vector2,v[g.pointerId]=L),L.set(g.pageX,g.pageY)}function et(g){const L=g.pointerId===x[0].pointerId?x[1]:x[0];return v[L.pointerId]}e.domElement.addEventListener("contextmenu",gn),e.domElement.addEventListener("pointerdown",Me),e.domElement.addEventListener("pointercancel",fn),e.domElement.addEventListener("wheel",mn,{passive:!1}),this.update()}}const Sn={name:"OrbitControls",render:()=>null},ft=d.defineComponent({...Sn,props:{enablePan:{type:Boolean,default:!0},enableRotate:{type:Boolean,default:!0},enableZoom:{type:Boolean,default:!0},minZoom:{default:0},maxZoom:{default:1/0},minDistance:{default:0},maxDistance:{default:1/0},minPolarAngle:{default:0},maxPolarAngle:{default:Math.PI},minAzimuthAngle:{default:1/0},maxAzimuthAngle:{default:1/0},target:{default:()=>[0,0,0]}},setup(l,{expose:s}){const t=l,e=d.ref(null);d.inject("addControls")(e);const n=d.inject("parentCamera"),i=d.inject("canvas");function o(){e.value!=null&&(e.value.enablePan=t.enablePan,e.value.enableRotate=t.enableRotate,e.value.enableZoom=t.enableZoom,e.value.minZoom=t.minZoom,e.value.maxZoom=t.maxZoom,e.value.minDistance=t.minDistance,e.value.maxDistance=t.maxDistance,e.value.minPolarAngle=t.minPolarAngle,e.value.maxPolarAngle=t.maxPolarAngle,e.value.minAzimuthAngle=t.minAzimuthAngle,e.value.maxAzimuthAngle=t.maxAzimuthAngle)}let r=!1;const c=()=>{i.value&&(r||(e.value=new En(n,i.value),o(),C(t,"target",e.value),r=!0))};return d.watch(i,()=>{c()}),o(),b(t,"enablePan",o),b(t,"enableRotate",o),b(t,"enableZoom",o),b(t,"minZoom",o),b(t,"maxZoom",o),b(t,"minDistance",o),b(t,"maxDistance",o),b(t,"minPolarAngle",o),b(t,"maxPolarAngle",o),b(t,"minAzimuthAngle",o),b(t,"maxAzimuthAngle",o),s({three:e}),{props:t,three:e,camera:n,canvas:i,applyProps:o,get boundCamera(){return r},set boundCamera(u){r=u},tryBindCamera:c}}}),He={type:"change"},Ue={type:"start"},Ve={type:"end"};class Tn extends a.EventDispatcher{constructor(s,t){super(),t===void 0&&console.warn('THREE.TrackballControls: The second parameter "domElement" is now mandatory.'),t===document&&console.error('THREE.TrackballControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');const e=this,n={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4};this.object=s,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.keys=["KeyA","KeyS","KeyD"],this.mouseButtons={LEFT:a.MOUSE.ROTATE,MIDDLE:a.MOUSE.DOLLY,RIGHT:a.MOUSE.PAN},this.target=new a.Vector3;const i=1e-6,o=new a.Vector3;let r=1,c=n.NONE,u=n.NONE,f=0,p=0,m=0;const h=new a.Vector3,w=new a.Vector2,_=new a.Vector2,E=new a.Vector3,y=new a.Vector2,S=new a.Vector2,T=new a.Vector2,A=new a.Vector2,x=[],v={};this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone(),this.zoom0=this.object.zoom,this.handleResize=function(){const M=e.domElement.getBoundingClientRect(),R=e.domElement.ownerDocument.documentElement;e.screen.left=M.left+window.pageXOffset-R.clientLeft,e.screen.top=M.top+window.pageYOffset-R.clientTop,e.screen.width=M.width,e.screen.height=M.height};const j=function(){const M=new a.Vector2;return function(U,$){return M.set((U-e.screen.left)/e.screen.width,($-e.screen.top)/e.screen.height),M}}(),G=function(){const M=new a.Vector2;return function(U,$){return M.set((U-e.screen.width*.5-e.screen.left)/(e.screen.width*.5),(e.screen.height+2*(e.screen.top-$))/e.screen.width),M}}();this.rotateCamera=function(){const M=new a.Vector3,R=new a.Quaternion,U=new a.Vector3,$=new a.Vector3,ee=new a.Vector3,oe=new a.Vector3;return function(){oe.set(_.x-w.x,_.y-w.y,0);let Me=oe.length();Me?(h.copy(e.object.position).sub(e.target),U.copy(h).normalize(),$.copy(e.object.up).normalize(),ee.crossVectors($,U).normalize(),$.setLength(_.y-w.y),ee.setLength(_.x-w.x),oe.copy($.add(ee)),M.crossVectors(oe,h).normalize(),Me*=e.rotateSpeed,R.setFromAxisAngle(M,Me),h.applyQuaternion(R),e.object.up.applyQuaternion(R),E.copy(M),m=Me):!e.staticMoving&&m&&(m*=Math.sqrt(1-e.dynamicDampingFactor),h.copy(e.object.position).sub(e.target),R.setFromAxisAngle(E,m),h.applyQuaternion(R),e.object.up.applyQuaternion(R)),w.copy(_)}}(),this.zoomCamera=function(){let M;c===n.TOUCH_ZOOM_PAN?(M=f/p,f=p,e.object.isPerspectiveCamera?h.multiplyScalar(M):e.object.isOrthographicCamera?(e.object.zoom/=M,e.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(M=1+(S.y-y.y)*e.zoomSpeed,M!==1&&M>0&&(e.object.isPerspectiveCamera?h.multiplyScalar(M):e.object.isOrthographicCamera?(e.object.zoom/=M,e.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),e.staticMoving?y.copy(S):y.y+=(S.y-y.y)*this.dynamicDampingFactor)},this.panCamera=function(){const M=new a.Vector2,R=new a.Vector3,U=new a.Vector3;return function(){if(M.copy(A).sub(T),M.lengthSq()){if(e.object.isOrthographicCamera){const ee=(e.object.right-e.object.left)/e.object.zoom/e.domElement.clientWidth,oe=(e.object.top-e.object.bottom)/e.object.zoom/e.domElement.clientWidth;M.x*=ee,M.y*=oe}M.multiplyScalar(h.length()*e.panSpeed),U.copy(h).cross(e.object.up).setLength(M.x),U.add(R.copy(e.object.up).setLength(M.y)),e.object.position.add(U),e.target.add(U),e.staticMoving?T.copy(A):T.add(M.subVectors(A,T).multiplyScalar(e.dynamicDampingFactor))}}}(),this.checkDistances=function(){(!e.noZoom||!e.noPan)&&(h.lengthSq()>e.maxDistance*e.maxDistance&&(e.object.position.addVectors(e.target,h.setLength(e.maxDistance)),y.copy(S)),h.lengthSq()<e.minDistance*e.minDistance&&(e.object.position.addVectors(e.target,h.setLength(e.minDistance)),y.copy(S)))},this.update=function(){h.subVectors(e.object.position,e.target),e.noRotate||e.rotateCamera(),e.noZoom||e.zoomCamera(),e.noPan||e.panCamera(),e.object.position.addVectors(e.target,h),e.object.isPerspectiveCamera?(e.checkDistances(),e.object.lookAt(e.target),o.distanceToSquared(e.object.position)>i&&(e.dispatchEvent(He),o.copy(e.object.position))):e.object.isOrthographicCamera?(e.object.lookAt(e.target),(o.distanceToSquared(e.object.position)>i||r!==e.object.zoom)&&(e.dispatchEvent(He),o.copy(e.object.position),r=e.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type")},this.reset=function(){c=n.NONE,u=n.NONE,e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.up.copy(e.up0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),h.subVectors(e.object.position,e.target),e.object.lookAt(e.target),e.dispatchEvent(He),o.copy(e.object.position),r=e.object.zoom};function V(M){e.enabled!==!1&&(x.length===0&&(e.domElement.setPointerCapture(M.pointerId),e.domElement.addEventListener("pointermove",O),e.domElement.addEventListener("pointerup",B)),Re(M),M.pointerType==="touch"?z(M):D(M))}function O(M){e.enabled!==!1&&(M.pointerType==="touch"?fe(M):J(M))}function B(M){e.enabled!==!1&&(M.pointerType==="touch"?me(M):Y(),he(M),x.length===0&&(e.domElement.releasePointerCapture(M.pointerId),e.domElement.removeEventListener("pointermove",O),e.domElement.removeEventListener("pointerup",B)))}function Q(M){he(M)}function F(M){e.enabled!==!1&&(window.removeEventListener("keydown",F),u===n.NONE&&(M.code===e.keys[n.ROTATE]&&!e.noRotate?u=n.ROTATE:M.code===e.keys[n.ZOOM]&&!e.noZoom?u=n.ZOOM:M.code===e.keys[n.PAN]&&!e.noPan&&(u=n.PAN)))}function H(){e.enabled!==!1&&(u=n.NONE,window.addEventListener("keydown",F))}function D(M){if(c===n.NONE)switch(M.button){case e.mouseButtons.LEFT:c=n.ROTATE;break;case e.mouseButtons.MIDDLE:c=n.ZOOM;break;case e.mouseButtons.RIGHT:c=n.PAN;break}const R=u!==n.NONE?u:c;R===n.ROTATE&&!e.noRotate?(_.copy(G(M.pageX,M.pageY)),w.copy(_)):R===n.ZOOM&&!e.noZoom?(y.copy(j(M.pageX,M.pageY)),S.copy(y)):R===n.PAN&&!e.noPan&&(T.copy(j(M.pageX,M.pageY)),A.copy(T)),e.dispatchEvent(Ue)}function J(M){const R=u!==n.NONE?u:c;R===n.ROTATE&&!e.noRotate?(w.copy(_),_.copy(G(M.pageX,M.pageY))):R===n.ZOOM&&!e.noZoom?S.copy(j(M.pageX,M.pageY)):R===n.PAN&&!e.noPan&&A.copy(j(M.pageX,M.pageY))}function Y(){c=n.NONE,e.dispatchEvent(Ve)}function q(M){if(e.enabled!==!1&&e.noZoom!==!0){switch(M.preventDefault(),M.deltaMode){case 2:y.y-=M.deltaY*.025;break;case 1:y.y-=M.deltaY*.01;break;default:y.y-=M.deltaY*25e-5;break}e.dispatchEvent(Ue),e.dispatchEvent(Ve)}}function z(M){switch(Ce(M),x.length){case 1:c=n.TOUCH_ROTATE,_.copy(G(x[0].pageX,x[0].pageY)),w.copy(_);break;default:c=n.TOUCH_ZOOM_PAN;const R=x[0].pageX-x[1].pageX,U=x[0].pageY-x[1].pageY;p=f=Math.sqrt(R*R+U*U);const $=(x[0].pageX+x[1].pageX)/2,ee=(x[0].pageY+x[1].pageY)/2;T.copy(j($,ee)),A.copy(T);break}e.dispatchEvent(Ue)}function fe(M){switch(Ce(M),x.length){case 1:w.copy(_),_.copy(G(M.pageX,M.pageY));break;default:const R=De(M),U=M.pageX-R.x,$=M.pageY-R.y;p=Math.sqrt(U*U+$*$);const ee=(M.pageX+R.x)/2,oe=(M.pageY+R.y)/2;A.copy(j(ee,oe));break}}function me(M){switch(x.length){case 0:c=n.NONE;break;case 1:c=n.TOUCH_ROTATE,_.copy(G(M.pageX,M.pageY)),w.copy(_);break;case 2:c=n.TOUCH_ZOOM_PAN,_.copy(G(M.pageX-w.x,M.pageY-w.y)),w.copy(_);break}e.dispatchEvent(Ve)}function ce(M){e.enabled!==!1&&M.preventDefault()}function Re(M){x.push(M)}function he(M){delete v[M.pointerId];for(let R=0;R<x.length;R++)if(x[R].pointerId==M.pointerId){x.splice(R,1);return}}function Ce(M){let R=v[M.pointerId];R===void 0&&(R=new a.Vector2,v[M.pointerId]=R),R.set(M.pageX,M.pageY)}function De(M){const R=M.pointerId===x[0].pointerId?x[1]:x[0];return v[R.pointerId]}this.dispose=function(){e.domElement.removeEventListener("contextmenu",ce),e.domElement.removeEventListener("pointerdown",V),e.domElement.removeEventListener("pointercancel",Q),e.domElement.removeEventListener("wheel",q),e.domElement.removeEventListener("pointermove",O),e.domElement.removeEventListener("pointerup",B),window.removeEventListener("keydown",F),window.removeEventListener("keyup",H)},this.domElement.addEventListener("contextmenu",ce),this.domElement.addEventListener("pointerdown",V),this.domElement.addEventListener("pointercancel",Q),this.domElement.addEventListener("wheel",q,{passive:!1}),window.addEventListener("keydown",F),window.addEventListener("keyup",H),this.handleResize(),this.update()}}const xn={name:"TrackballControls",render:()=>null},mt=d.defineComponent({...xn,props:{minDistance:{default:0},maxDistance:{default:1/0},panSpeed:{default:.3},rotateSpeed:{default:1},zoomSpeed:{default:1.2}},setup(l,{expose:s}){const t=l,e=d.ref(null);d.inject("addControls")(e);const n=d.inject("parentCamera"),i=d.inject("canvas");function o(){e.value!=null&&(e.value.rotateSpeed=t.rotateSpeed,e.value.zoomSpeed=t.zoomSpeed,e.value.panSpeed=t.panSpeed,e.value.minDistance=t.minDistance,e.value.maxDistance=t.maxDistance)}let r=!1;const c=()=>{i.value&&(r||(e.value=new Tn(n,i.value),o(),r=!0))};return d.watch(i,()=>{c()}),o(),b(t,"panSpeed",o),b(t,"rotateSpeed",o),b(t,"zoomSpeed",o),b(t,"minDistance",o),b(t,"maxDistance",o),s({three:e}),{props:t,three:e,camera:n,canvas:i,applyProps:o,get boundCamera(){return r},set boundCamera(u){r=u},tryBindCamera:c}}}),ge=new a.Raycaster,K=new a.Vector3,de=new a.Vector3,k=new a.Quaternion,ht={X:new a.Vector3(1,0,0),Y:new a.Vector3(0,1,0),Z:new a.Vector3(0,0,1)},ze={type:"change"},gt={type:"mouseDown"},yt={type:"mouseUp",mode:null},wt={type:"objectChange"};class An extends a.Object3D{constructor(s,t){super(),t===void 0&&(console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.'),t=document),this.isTransformControls=!0,this.visible=!1,this.domElement=t,this.domElement.style.touchAction="none";const e=new On;this._gizmo=e,this.add(e);const n=new vn;this._plane=n,this.add(n);const i=this;function o(S,T){let A=T;Object.defineProperty(i,S,{get:function(){return A!==void 0?A:T},set:function(x){A!==x&&(A=x,n[S]=x,e[S]=x,i.dispatchEvent({type:S+"-changed",value:x}),i.dispatchEvent(ze))}}),i[S]=T,n[S]=T,e[S]=T}o("camera",s),o("object",void 0),o("enabled",!0),o("axis",null),o("mode","translate"),o("translationSnap",null),o("rotationSnap",null),o("scaleSnap",null),o("space","world"),o("size",1),o("dragging",!1),o("showX",!0),o("showY",!0),o("showZ",!0);const r=new a.Vector3,c=new a.Vector3,u=new a.Quaternion,f=new a.Quaternion,p=new a.Vector3,m=new a.Quaternion,h=new a.Vector3,w=new a.Vector3,_=new a.Vector3,E=0,y=new a.Vector3;o("worldPosition",r),o("worldPositionStart",c),o("worldQuaternion",u),o("worldQuaternionStart",f),o("cameraPosition",p),o("cameraQuaternion",m),o("pointStart",h),o("pointEnd",w),o("rotationAxis",_),o("rotationAngle",E),o("eye",y),this._offset=new a.Vector3,this._startNorm=new a.Vector3,this._endNorm=new a.Vector3,this._cameraScale=new a.Vector3,this._parentPosition=new a.Vector3,this._parentQuaternion=new a.Quaternion,this._parentQuaternionInv=new a.Quaternion,this._parentScale=new a.Vector3,this._worldScaleStart=new a.Vector3,this._worldQuaternionInv=new a.Quaternion,this._worldScale=new a.Vector3,this._positionStart=new a.Vector3,this._quaternionStart=new a.Quaternion,this._scaleStart=new a.Vector3,this._getPointer=Ln.bind(this),this._onPointerDown=Rn.bind(this),this._onPointerHover=Pn.bind(this),this._onPointerMove=Cn.bind(this),this._onPointerUp=In.bind(this),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointermove",this._onPointerHover),this.domElement.addEventListener("pointerup",this._onPointerUp)}updateMatrixWorld(){this.object!==void 0&&(this.object.updateMatrixWorld(),this.object.parent===null?console.error("TransformControls: The attached 3D object must be a part of the scene graph."):this.object.parent.matrixWorld.decompose(this._parentPosition,this._parentQuaternion,this._parentScale),this.object.matrixWorld.decompose(this.worldPosition,this.worldQuaternion,this._worldScale),this._parentQuaternionInv.copy(this._parentQuaternion).invert(),this._worldQuaternionInv.copy(this.worldQuaternion).invert()),this.camera.updateMatrixWorld(),this.camera.matrixWorld.decompose(this.cameraPosition,this.cameraQuaternion,this._cameraScale),this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),super.updateMatrixWorld(this)}pointerHover(s){if(this.object===void 0||this.dragging===!0)return;ge.setFromCamera(s,this.camera);const t=Xe(this._gizmo.picker[this.mode],ge);t?this.axis=t.object.name:this.axis=null}pointerDown(s){if(!(this.object===void 0||this.dragging===!0||s.button!==0)&&this.axis!==null){ge.setFromCamera(s,this.camera);const t=Xe(this._plane,ge,!0);t&&(this.object.updateMatrixWorld(),this.object.parent.updateMatrixWorld(),this._positionStart.copy(this.object.position),this._quaternionStart.copy(this.object.quaternion),this._scaleStart.copy(this.object.scale),this.object.matrixWorld.decompose(this.worldPositionStart,this.worldQuaternionStart,this._worldScaleStart),this.pointStart.copy(t.point).sub(this.worldPositionStart)),this.dragging=!0,gt.mode=this.mode,this.dispatchEvent(gt)}}pointerMove(s){const t=this.axis,e=this.mode,n=this.object;let i=this.space;if(e==="scale"?i="local":(t==="E"||t==="XYZE"||t==="XYZ")&&(i="world"),n===void 0||t===null||this.dragging===!1||s.button!==-1)return;ge.setFromCamera(s,this.camera);const o=Xe(this._plane,ge,!0);if(o){if(this.pointEnd.copy(o.point).sub(this.worldPositionStart),e==="translate")this._offset.copy(this.pointEnd).sub(this.pointStart),i==="local"&&t!=="XYZ"&&this._offset.applyQuaternion(this._worldQuaternionInv),t.indexOf("X")===-1&&(this._offset.x=0),t.indexOf("Y")===-1&&(this._offset.y=0),t.indexOf("Z")===-1&&(this._offset.z=0),i==="local"&&t!=="XYZ"?this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale):this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale),n.position.copy(this._offset).add(this._positionStart),this.translationSnap&&(i==="local"&&(n.position.applyQuaternion(k.copy(this._quaternionStart).invert()),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.position.applyQuaternion(this._quaternionStart)),i==="world"&&(n.parent&&n.position.add(K.setFromMatrixPosition(n.parent.matrixWorld)),t.search("X")!==-1&&(n.position.x=Math.round(n.position.x/this.translationSnap)*this.translationSnap),t.search("Y")!==-1&&(n.position.y=Math.round(n.position.y/this.translationSnap)*this.translationSnap),t.search("Z")!==-1&&(n.position.z=Math.round(n.position.z/this.translationSnap)*this.translationSnap),n.parent&&n.position.sub(K.setFromMatrixPosition(n.parent.matrixWorld))));else if(e==="scale"){if(t.search("XYZ")!==-1){let r=this.pointEnd.length()/this.pointStart.length();this.pointEnd.dot(this.pointStart)<0&&(r*=-1),de.set(r,r,r)}else K.copy(this.pointStart),de.copy(this.pointEnd),K.applyQuaternion(this._worldQuaternionInv),de.applyQuaternion(this._worldQuaternionInv),de.divide(K),t.search("X")===-1&&(de.x=1),t.search("Y")===-1&&(de.y=1),t.search("Z")===-1&&(de.z=1);n.scale.copy(this._scaleStart).multiply(de),this.scaleSnap&&(t.search("X")!==-1&&(n.scale.x=Math.round(n.scale.x/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Y")!==-1&&(n.scale.y=Math.round(n.scale.y/this.scaleSnap)*this.scaleSnap||this.scaleSnap),t.search("Z")!==-1&&(n.scale.z=Math.round(n.scale.z/this.scaleSnap)*this.scaleSnap||this.scaleSnap))}else if(e==="rotate"){this._offset.copy(this.pointEnd).sub(this.pointStart);const r=20/this.worldPosition.distanceTo(K.setFromMatrixPosition(this.camera.matrixWorld));t==="E"?(this.rotationAxis.copy(this.eye),this.rotationAngle=this.pointEnd.angleTo(this.pointStart),this._startNorm.copy(this.pointStart).normalize(),this._endNorm.copy(this.pointEnd).normalize(),this.rotationAngle*=this._endNorm.cross(this._startNorm).dot(this.eye)<0?1:-1):t==="XYZE"?(this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),this.rotationAngle=this._offset.dot(K.copy(this.rotationAxis).cross(this.eye))*r):(t==="X"||t==="Y"||t==="Z")&&(this.rotationAxis.copy(ht[t]),K.copy(ht[t]),i==="local"&&K.applyQuaternion(this.worldQuaternion),this.rotationAngle=this._offset.dot(K.cross(this.eye).normalize())*r),this.rotationSnap&&(this.rotationAngle=Math.round(this.rotationAngle/this.rotationSnap)*this.rotationSnap),i==="local"&&t!=="E"&&t!=="XYZE"?(n.quaternion.copy(this._quaternionStart),n.quaternion.multiply(k.setFromAxisAngle(this.rotationAxis,this.rotationAngle)).normalize()):(this.rotationAxis.applyQuaternion(this._parentQuaternionInv),n.quaternion.copy(k.setFromAxisAngle(this.rotationAxis,this.rotationAngle)),n.quaternion.multiply(this._quaternionStart).normalize())}this.dispatchEvent(ze),this.dispatchEvent(wt)}}pointerUp(s){s.button===0&&(this.dragging&&this.axis!==null&&(yt.mode=this.mode,this.dispatchEvent(yt)),this.dragging=!1,this.axis=null)}dispose(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerHover),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.traverse(function(s){s.geometry&&s.geometry.dispose(),s.material&&s.material.dispose()})}attach(s){return this.object=s,this.visible=!0,this}detach(){return this.object=void 0,this.visible=!1,this.axis=null,this}reset(){this.enabled&&this.dragging&&(this.object.position.copy(this._positionStart),this.object.quaternion.copy(this._quaternionStart),this.object.scale.copy(this._scaleStart),this.dispatchEvent(ze),this.dispatchEvent(wt),this.pointStart.copy(this.pointEnd))}getRaycaster(){return ge}getMode(){return this.mode}setMode(s){this.mode=s}setTranslationSnap(s){this.translationSnap=s}setRotationSnap(s){this.rotationSnap=s}setScaleSnap(s){this.scaleSnap=s}setSize(s){this.size=s}setSpace(s){this.space=s}update(){console.warn("THREE.TransformControls: update function has no more functionality and therefore has been deprecated.")}}function Ln(l){if(this.domElement.ownerDocument.pointerLockElement)return{x:0,y:0,button:l.button};{const s=this.domElement.getBoundingClientRect();return{x:(l.clientX-s.left)/s.width*2-1,y:-(l.clientY-s.top)/s.height*2+1,button:l.button}}}function Pn(l){if(this.enabled)switch(l.pointerType){case"mouse":case"pen":this.pointerHover(this._getPointer(l));break}}function Rn(l){this.enabled&&(document.pointerLockElement||this.domElement.setPointerCapture(l.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.pointerHover(this._getPointer(l)),this.pointerDown(this._getPointer(l)))}function Cn(l){this.enabled&&this.pointerMove(this._getPointer(l))}function In(l){this.enabled&&(this.domElement.releasePointerCapture(l.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.pointerUp(this._getPointer(l)))}function Xe(l,s,t){const e=s.intersectObject(l,!0);for(let n=0;n<e.length;n++)if(e[n].object.visible||t)return e[n];return!1}const Ie=new a.Euler,N=new a.Vector3(0,1,0),Mt=new a.Vector3(0,0,0),bt=new a.Matrix4,Oe=new a.Quaternion,ve=new a.Quaternion,se=new a.Vector3,_t=new a.Matrix4,Ee=new a.Vector3(1,0,0),ye=new a.Vector3(0,1,0),Se=new a.Vector3(0,0,1),Ge=new a.Vector3,Te=new a.Vector3,xe=new a.Vector3;class On extends a.Object3D{constructor(){super(),this.isTransformControlsGizmo=!0,this.type="TransformControlsGizmo";const s=new a.MeshBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),t=new a.LineBasicMaterial({depthTest:!1,depthWrite:!1,fog:!1,toneMapped:!1,transparent:!0}),e=s.clone();e.opacity=.15;const n=t.clone();n.opacity=.5;const i=s.clone();i.color.setHex(16711680);const o=s.clone();o.color.setHex(65280);const r=s.clone();r.color.setHex(255);const c=s.clone();c.color.setHex(16711680),c.opacity=.5;const u=s.clone();u.color.setHex(65280),u.opacity=.5;const f=s.clone();f.color.setHex(255),f.opacity=.5;const p=s.clone();p.opacity=.25;const m=s.clone();m.color.setHex(16776960),m.opacity=.25,s.clone().color.setHex(16776960);const w=s.clone();w.color.setHex(7895160);const _=new a.CylinderGeometry(0,.04,.1,12);_.translate(0,.05,0);const E=new a.BoxGeometry(.08,.08,.08);E.translate(0,.04,0);const y=new a.BufferGeometry;y.setAttribute("position",new a.Float32BufferAttribute([0,0,0,1,0,0],3));const S=new a.CylinderGeometry(.0075,.0075,.5,3);S.translate(0,.25,0);function T(D,J){const Y=new a.TorusGeometry(D,.0075,3,64,J*Math.PI*2);return Y.rotateY(Math.PI/2),Y.rotateX(Math.PI/2),Y}function A(){const D=new a.BufferGeometry;return D.setAttribute("position",new a.Float32BufferAttribute([0,0,0,1,1,1],3)),D}const x={X:[[new a.Mesh(_,i),[.5,0,0],[0,0,-Math.PI/2]],[new a.Mesh(_,i),[-.5,0,0],[0,0,Math.PI/2]],[new a.Mesh(S,i),[0,0,0],[0,0,-Math.PI/2]]],Y:[[new a.Mesh(_,o),[0,.5,0]],[new a.Mesh(_,o),[0,-.5,0],[Math.PI,0,0]],[new a.Mesh(S,o)]],Z:[[new a.Mesh(_,r),[0,0,.5],[Math.PI/2,0,0]],[new a.Mesh(_,r),[0,0,-.5],[-Math.PI/2,0,0]],[new a.Mesh(S,r),null,[Math.PI/2,0,0]]],XYZ:[[new a.Mesh(new a.OctahedronGeometry(.1,0),p.clone()),[0,0,0]]],XY:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),f.clone()),[.15,.15,0]]],YZ:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),c.clone()),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),u.clone()),[.15,0,.15],[-Math.PI/2,0,0]]]},v={X:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[.3,0,0],[0,0,-Math.PI/2]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,.3,0]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,-.3,0],[0,0,Math.PI]]],Z:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,0,.3],[Math.PI/2,0,0]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,0,-.3],[-Math.PI/2,0,0]]],XYZ:[[new a.Mesh(new a.OctahedronGeometry(.2,0),e)]],XY:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[.15,.15,0]]],YZ:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[.15,0,.15],[-Math.PI/2,0,0]]]},j={START:[[new a.Mesh(new a.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],END:[[new a.Mesh(new a.OctahedronGeometry(.01,2),n),null,null,null,"helper"]],DELTA:[[new a.Line(A(),n),null,null,null,"helper"]],X:[[new a.Line(y,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new a.Line(y,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new a.Line(y,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]},G={XYZE:[[new a.Mesh(T(.5,1),w),null,[0,Math.PI/2,0]]],X:[[new a.Mesh(T(.5,.5),i)]],Y:[[new a.Mesh(T(.5,.5),o),null,[0,0,-Math.PI/2]]],Z:[[new a.Mesh(T(.5,.5),r),null,[0,Math.PI/2,0]]],E:[[new a.Mesh(T(.75,1),m),null,[0,Math.PI/2,0]]]},V={AXIS:[[new a.Line(y,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]]},O={XYZE:[[new a.Mesh(new a.SphereGeometry(.25,10,8),e)]],X:[[new a.Mesh(new a.TorusGeometry(.5,.1,4,24),e),[0,0,0],[0,-Math.PI/2,-Math.PI/2]]],Y:[[new a.Mesh(new a.TorusGeometry(.5,.1,4,24),e),[0,0,0],[Math.PI/2,0,0]]],Z:[[new a.Mesh(new a.TorusGeometry(.5,.1,4,24),e),[0,0,0],[0,0,-Math.PI/2]]],E:[[new a.Mesh(new a.TorusGeometry(.75,.1,2,24),e)]]},B={X:[[new a.Mesh(E,i),[.5,0,0],[0,0,-Math.PI/2]],[new a.Mesh(S,i),[0,0,0],[0,0,-Math.PI/2]],[new a.Mesh(E,i),[-.5,0,0],[0,0,Math.PI/2]]],Y:[[new a.Mesh(E,o),[0,.5,0]],[new a.Mesh(S,o)],[new a.Mesh(E,o),[0,-.5,0],[0,0,Math.PI]]],Z:[[new a.Mesh(E,r),[0,0,.5],[Math.PI/2,0,0]],[new a.Mesh(S,r),[0,0,0],[Math.PI/2,0,0]],[new a.Mesh(E,r),[0,0,-.5],[-Math.PI/2,0,0]]],XY:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),f),[.15,.15,0]]],YZ:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),c),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new a.Mesh(new a.BoxGeometry(.15,.15,.01),u),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new a.Mesh(new a.BoxGeometry(.1,.1,.1),p.clone())]]},Q={X:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[.3,0,0],[0,0,-Math.PI/2]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[-.3,0,0],[0,0,Math.PI/2]]],Y:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,.3,0]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,-.3,0],[0,0,Math.PI]]],Z:[[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,0,.3],[Math.PI/2,0,0]],[new a.Mesh(new a.CylinderGeometry(.2,0,.6,4),e),[0,0,-.3],[-Math.PI/2,0,0]]],XY:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[.15,.15,0]]],YZ:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[0,.15,.15],[0,Math.PI/2,0]]],XZ:[[new a.Mesh(new a.BoxGeometry(.2,.2,.01),e),[.15,0,.15],[-Math.PI/2,0,0]]],XYZ:[[new a.Mesh(new a.BoxGeometry(.2,.2,.2),e),[0,0,0]]]},F={X:[[new a.Line(y,n.clone()),[-1e3,0,0],null,[1e6,1,1],"helper"]],Y:[[new a.Line(y,n.clone()),[0,-1e3,0],[0,0,Math.PI/2],[1e6,1,1],"helper"]],Z:[[new a.Line(y,n.clone()),[0,0,-1e3],[0,-Math.PI/2,0],[1e6,1,1],"helper"]]};function H(D){const J=new a.Object3D;for(const Y in D)for(let q=D[Y].length;q--;){const z=D[Y][q][0].clone(),fe=D[Y][q][1],me=D[Y][q][2],ce=D[Y][q][3],Re=D[Y][q][4];z.name=Y,z.tag=Re,fe&&z.position.set(fe[0],fe[1],fe[2]),me&&z.rotation.set(me[0],me[1],me[2]),ce&&z.scale.set(ce[0],ce[1],ce[2]),z.updateMatrix();const he=z.geometry.clone();he.applyMatrix4(z.matrix),z.geometry=he,z.renderOrder=1/0,z.position.set(0,0,0),z.rotation.set(0,0,0),z.scale.set(1,1,1),J.add(z)}return J}this.gizmo={},this.picker={},this.helper={},this.add(this.gizmo.translate=H(x)),this.add(this.gizmo.rotate=H(G)),this.add(this.gizmo.scale=H(B)),this.add(this.picker.translate=H(v)),this.add(this.picker.rotate=H(O)),this.add(this.picker.scale=H(Q)),this.add(this.helper.translate=H(j)),this.add(this.helper.rotate=H(V)),this.add(this.helper.scale=H(F)),this.picker.translate.visible=!1,this.picker.rotate.visible=!1,this.picker.scale.visible=!1}updateMatrixWorld(s){const e=(this.mode==="scale"?"local":this.space)==="local"?this.worldQuaternion:ve;this.gizmo.translate.visible=this.mode==="translate",this.gizmo.rotate.visible=this.mode==="rotate",this.gizmo.scale.visible=this.mode==="scale",this.helper.translate.visible=this.mode==="translate",this.helper.rotate.visible=this.mode==="rotate",this.helper.scale.visible=this.mode==="scale";let n=[];n=n.concat(this.picker[this.mode].children),n=n.concat(this.gizmo[this.mode].children),n=n.concat(this.helper[this.mode].children);for(let i=0;i<n.length;i++){const o=n[i];o.visible=!0,o.rotation.set(0,0,0),o.position.copy(this.worldPosition);let r;if(this.camera.isOrthographicCamera?r=(this.camera.top-this.camera.bottom)/this.camera.zoom:r=this.worldPosition.distanceTo(this.cameraPosition)*Math.min(1.9*Math.tan(Math.PI*this.camera.fov/360)/this.camera.zoom,7),o.scale.set(1,1,1).multiplyScalar(r*this.size/4),o.tag==="helper"){o.visible=!1,o.name==="AXIS"?(o.position.copy(this.worldPositionStart),o.visible=!!this.axis,this.axis==="X"&&(k.setFromEuler(Ie.set(0,0,0)),o.quaternion.copy(e).multiply(k),Math.abs(N.copy(Ee).applyQuaternion(e).dot(this.eye))>.9&&(o.visible=!1)),this.axis==="Y"&&(k.setFromEuler(Ie.set(0,0,Math.PI/2)),o.quaternion.copy(e).multiply(k),Math.abs(N.copy(ye).applyQuaternion(e).dot(this.eye))>.9&&(o.visible=!1)),this.axis==="Z"&&(k.setFromEuler(Ie.set(0,Math.PI/2,0)),o.quaternion.copy(e).multiply(k),Math.abs(N.copy(Se).applyQuaternion(e).dot(this.eye))>.9&&(o.visible=!1)),this.axis==="XYZE"&&(k.setFromEuler(Ie.set(0,Math.PI/2,0)),N.copy(this.rotationAxis),o.quaternion.setFromRotationMatrix(bt.lookAt(Mt,N,ye)),o.quaternion.multiply(k),o.visible=this.dragging),this.axis==="E"&&(o.visible=!1)):o.name==="START"?(o.position.copy(this.worldPositionStart),o.visible=this.dragging):o.name==="END"?(o.position.copy(this.worldPosition),o.visible=this.dragging):o.name==="DELTA"?(o.position.copy(this.worldPositionStart),o.quaternion.copy(this.worldQuaternionStart),K.set(1e-10,1e-10,1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1),K.applyQuaternion(this.worldQuaternionStart.clone().invert()),o.scale.copy(K),o.visible=this.dragging):(o.quaternion.copy(e),this.dragging?o.position.copy(this.worldPositionStart):o.position.copy(this.worldPosition),this.axis&&(o.visible=this.axis.search(o.name)!==-1));continue}o.quaternion.copy(e),this.mode==="translate"||this.mode==="scale"?(o.name==="X"&&Math.abs(N.copy(Ee).applyQuaternion(e).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),o.name==="Y"&&Math.abs(N.copy(ye).applyQuaternion(e).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),o.name==="Z"&&Math.abs(N.copy(Se).applyQuaternion(e).dot(this.eye))>.99&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),o.name==="XY"&&Math.abs(N.copy(Se).applyQuaternion(e).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),o.name==="YZ"&&Math.abs(N.copy(Ee).applyQuaternion(e).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1),o.name==="XZ"&&Math.abs(N.copy(ye).applyQuaternion(e).dot(this.eye))<.2&&(o.scale.set(1e-10,1e-10,1e-10),o.visible=!1)):this.mode==="rotate"&&(Oe.copy(e),N.copy(this.eye).applyQuaternion(k.copy(e).invert()),o.name.search("E")!==-1&&o.quaternion.setFromRotationMatrix(bt.lookAt(this.eye,Mt,ye)),o.name==="X"&&(k.setFromAxisAngle(Ee,Math.atan2(-N.y,N.z)),k.multiplyQuaternions(Oe,k),o.quaternion.copy(k)),o.name==="Y"&&(k.setFromAxisAngle(ye,Math.atan2(N.x,N.z)),k.multiplyQuaternions(Oe,k),o.quaternion.copy(k)),o.name==="Z"&&(k.setFromAxisAngle(Se,Math.atan2(N.y,N.x)),k.multiplyQuaternions(Oe,k),o.quaternion.copy(k))),o.visible=o.visible&&(o.name.indexOf("X")===-1||this.showX),o.visible=o.visible&&(o.name.indexOf("Y")===-1||this.showY),o.visible=o.visible&&(o.name.indexOf("Z")===-1||this.showZ),o.visible=o.visible&&(o.name.indexOf("E")===-1||this.showX&&this.showY&&this.showZ),o.material._color=o.material._color||o.material.color.clone(),o.material._opacity=o.material._opacity||o.material.opacity,o.material.color.copy(o.material._color),o.material.opacity=o.material._opacity,this.enabled&&this.axis&&(o.name===this.axis||this.axis.split("").some(function(c){return o.name===c}))&&(o.material.color.setHex(16776960),o.material.opacity=1)}super.updateMatrixWorld(s)}}class vn extends a.Mesh{constructor(){super(new a.PlaneGeometry(1e5,1e5,2,2),new a.MeshBasicMaterial({visible:!1,wireframe:!0,side:a.DoubleSide,transparent:!0,opacity:.1,toneMapped:!1})),this.isTransformControlsPlane=!0,this.type="TransformControlsPlane"}updateMatrixWorld(s){let t=this.space;switch(this.position.copy(this.worldPosition),this.mode==="scale"&&(t="local"),Ge.copy(Ee).applyQuaternion(t==="local"?this.worldQuaternion:ve),Te.copy(ye).applyQuaternion(t==="local"?this.worldQuaternion:ve),xe.copy(Se).applyQuaternion(t==="local"?this.worldQuaternion:ve),N.copy(Te),this.mode){case"translate":case"scale":switch(this.axis){case"X":N.copy(this.eye).cross(Ge),se.copy(Ge).cross(N);break;case"Y":N.copy(this.eye).cross(Te),se.copy(Te).cross(N);break;case"Z":N.copy(this.eye).cross(xe),se.copy(xe).cross(N);break;case"XY":se.copy(xe);break;case"YZ":se.copy(Ge);break;case"XZ":N.copy(xe),se.copy(Te);break;case"XYZ":case"E":se.set(0,0,0);break}break;case"rotate":default:se.set(0,0,0)}se.length()===0?this.quaternion.copy(this.cameraQuaternion):(_t.lookAt(K.set(0,0,0),se,N),this.quaternion.setFromRotationMatrix(_t)),super.updateMatrixWorld(s)}}const Gn={name:"TransformControls",render:()=>null},Et=d.defineComponent({...Gn,props:{mode:{default:"translate"},position:null,rotationSnap:{default:null},showX:{type:Boolean,default:!0},showY:{type:Boolean,default:!0},showZ:{type:Boolean,default:!0},size:{default:1},translationSnap:{default:null}},setup(l,{expose:s}){const t=l,e=d.shallowRef(null),n=d.inject("scene"),i=d.inject("mesh",null),o=d.inject("parent",void 0),r=d.inject("camera"),c=d.inject("canvas"),u=d.inject("enableAllControls"),f=d.inject("disableAllControls");function p(){e.value!=null&&(e.value.mode=t.mode,e.value.size=t.size,e.value.showX=t.showX,e.value.showY=t.showY,e.value.showZ=t.showZ,e.value.translationSnap=t.translationSnap,e.value.rotationSnap=t.rotationSnap)}let m=!1;const h=()=>{!c.value&&!r.value||m||(e.value=new An(r.value,c.value),C(t,"position",e.value),i?e.value.attach(i):o&&e.value.attach(o),e.value.addEventListener("dragging-changed",function(w){w.value?f():u()}),n.add(e.value),p(),m=!0)};return d.watch(c,()=>{h()}),p(),b(t,"mode",p),b(t,"size",p),b(t,"showX",p),b(t,"showY",p),b(t,"showZ",p),b(t,"rotationSnap",p),b(t,"translationSnap",p),d.onUnmounted(()=>{n.remove(e.value),ie(e.value)}),s({three:e}),{props:t,three:e,scene:n,mesh:i,parent:o,camera:r,canvas:c,enableAllControls:u,disableAllControls:f,applyProps:p,get boundCamera(){return m},set boundCamera(w){m=w},tryBindCamera:h}}}),St=d.defineComponent({__name:"Group",props:{enableRaycasting:{type:Boolean,default:!1},position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},emits:["click","mousemove","mouseenter","mouseleave"],setup(l,{expose:s,emit:t}){const e=l,n=new a.Group;return ae(n),C(e,"position",n),C(e,"rotation",n),C(e,"scale",n),Fe(n.children,e,t),d.provide("parent",n),s({three:n}),(i,o)=>d.renderSlot(i.$slots,"default")}}),Tt=d.defineComponent({__name:"InstancedMesh",props:{castShadow:{type:Boolean,default:!1},count:null,geometry:{default:null},material:{default:null},receiveShadow:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.MeshBasicMaterial,o=new a.InstancedMesh(n,i,t.count);o.castShadow=!0,o.receiveShadow=!0,ae(o);function r(){o.castShadow=t.castShadow,o.receiveShadow=t.receiveShadow}r(),b(t,"castShadow",r),b(t,"receiveShadow",r);const c=d.inject("getGeometry"),u=d.inject("getMaterial");return d.onMounted(()=>{if(t.geometry){const f=c(t.geometry);o.geometry=f}if(t.material){const f=u(t.material);o.material=f}}),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(f,p)=>d.renderSlot(f.$slots,"default")}}),xt=d.defineComponent({__name:"Line",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.LineBasicMaterial({color:"black"}),o=new a.Line(n,i);return ae(o),C(t,"position",o),C(t,"rotation",o),C(t,"scale",o),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(r,c)=>d.renderSlot(r.$slots,"default")}}),At=d.defineComponent({__name:"LineLoop",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.LineBasicMaterial({color:"black"}),o=new a.LineLoop(n,i);return ae(o),C(t,"position",o),C(t,"rotation",o),C(t,"scale",o),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(r,c)=>d.renderSlot(r.$slots,"default")}}),Lt=d.defineComponent({__name:"LineSegments",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.LineBasicMaterial({color:"black"}),o=new a.LineSegments(n,i);return ae(o),C(t,"position",o),C(t,"rotation",o),C(t,"scale",o),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(r,c)=>d.renderSlot(r.$slots,"default")}}),Pt=d.defineComponent({__name:"Mesh",props:{castShadow:{type:Boolean,default:!1},geometry:{default:null},material:{default:null},position:{default:()=>[0,0,0]},receiveShadow:{type:Boolean,default:!1},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.MeshBasicMaterial,o=new a.Mesh(n,i);o.castShadow=!0,o.receiveShadow=!0,ae(o),C(t,"position",o),C(t,"rotation",o),C(t,"scale",o);function r(){o.castShadow=t.castShadow,o.receiveShadow=t.receiveShadow}r(),b(t,"castShadow",r),b(t,"receiveShadow",r);const c=d.inject("getGeometry"),u=d.inject("getMaterial");return d.onMounted(()=>{if(t.geometry){const f=c(t.geometry);o.geometry=f}if(t.material){const f=u(t.material);o.material=f}}),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(f,p)=>d.renderSlot(f.$slots,"default")}}),Rt=d.defineComponent({__name:"Points",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.BufferGeometry,i=new a.PointsMaterial({color:"red",sizeAttenuation:!1,size:2}),o=new a.Points(n,i);return ae(o),C(t,"position",o),C(t,"rotation",o),C(t,"scale",o),d.onUnmounted(()=>{e.remove(o),ie(o)}),d.provide("mesh",o),s({three:o}),(r,c)=>d.renderSlot(r.$slots,"default")}});class jn extends a.Loader{constructor(s){super(s),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Bn(t)}),this.register(function(t){return new $n(t)}),this.register(function(t){return new Zn(t)}),this.register(function(t){return new Un(t)}),this.register(function(t){return new Vn(t)}),this.register(function(t){return new zn(t)}),this.register(function(t){return new Xn(t)}),this.register(function(t){return new Fn(t)}),this.register(function(t){return new Yn(t)}),this.register(function(t){return new Hn(t)}),this.register(function(t){return new Dn(t)}),this.register(function(t){return new Kn(t)})}load(s,t,e,n){const i=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=a.LoaderUtils.extractUrlBase(s),this.manager.itemStart(s);const r=function(u){n?n(u):console.error(u),i.manager.itemError(s),i.manager.itemEnd(s)},c=new a.FileLoader(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(s,function(u){try{i.parse(u,o,function(f){t(f),i.manager.itemEnd(s)},r)}catch(f){r(f)}},e,r)}setDRACOLoader(s){return this.dracoLoader=s,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(s){return this.ktx2Loader=s,this}setMeshoptDecoder(s){return this.meshoptDecoder=s,this}register(s){return this.pluginCallbacks.indexOf(s)===-1&&this.pluginCallbacks.push(s),this}unregister(s){return this.pluginCallbacks.indexOf(s)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(s),1),this}parse(s,t,e,n){let i;const o={},r={};if(typeof s=="string")i=s;else if(a.LoaderUtils.decodeText(new Uint8Array(s,0,4))===Ct){try{o[I.KHR_BINARY_GLTF]=new Qn(s)}catch(p){n&&n(p);return}i=o[I.KHR_BINARY_GLTF].content}else i=a.LoaderUtils.decodeText(new Uint8Array(s));const c=JSON.parse(i);if(c.asset===void 0||c.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const u=new ls(c,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});u.fileLoader.setRequestHeader(this.requestHeader);for(let f=0;f<this.pluginCallbacks.length;f++){const p=this.pluginCallbacks[f](u);r[p.name]=p,o[p.name]=!0}if(c.extensionsUsed)for(let f=0;f<c.extensionsUsed.length;++f){const p=c.extensionsUsed[f],m=c.extensionsRequired||[];switch(p){case I.KHR_MATERIALS_UNLIT:o[p]=new kn;break;case I.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:o[p]=new Jn;break;case I.KHR_DRACO_MESH_COMPRESSION:o[p]=new qn(c,this.dracoLoader);break;case I.KHR_TEXTURE_TRANSFORM:o[p]=new Wn;break;case I.KHR_MESH_QUANTIZATION:o[p]=new es;break;default:m.indexOf(p)>=0&&r[p]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+p+'".')}}u.setExtensions(o),u.setPlugins(r),u.parse(e,n)}parseAsync(s,t){const e=this;return new Promise(function(n,i){e.parse(s,t,n,i)})}}function Nn(){let l={};return{get:function(s){return l[s]},add:function(s,t){l[s]=t},remove:function(s){delete l[s]},removeAll:function(){l={}}}}const I={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Dn{constructor(s){this.parser=s,this.name=I.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const s=this.parser,t=this.parser.json.nodes||[];for(let e=0,n=t.length;e<n;e++){const i=t[e];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&s._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(s){const t=this.parser,e="light:"+s;let n=t.cache.get(e);if(n)return n;const i=t.json,c=((i.extensions&&i.extensions[this.name]||{}).lights||[])[s];let u;const f=new a.Color(16777215);c.color!==void 0&&f.fromArray(c.color);const p=c.range!==void 0?c.range:0;switch(c.type){case"directional":u=new a.DirectionalLight(f),u.target.position.set(0,0,-1),u.add(u.target);break;case"point":u=new a.PointLight(f),u.distance=p;break;case"spot":u=new a.SpotLight(f),u.distance=p,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,u.angle=c.spot.outerConeAngle,u.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,u.target.position.set(0,0,-1),u.add(u.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return u.position.set(0,0,0),u.decay=2,c.intensity!==void 0&&(u.intensity=c.intensity),u.name=t.createUniqueName(c.name||"light_"+s),n=Promise.resolve(u),t.cache.add(e,n),n}createNodeAttachment(s){const t=this,e=this.parser,i=e.json.nodes[s],r=(i.extensions&&i.extensions[this.name]||{}).light;return r===void 0?null:this._loadLight(r).then(function(c){return e._getNodeRef(t.cache,r,c)})}}class kn{constructor(){this.name=I.KHR_MATERIALS_UNLIT}getMaterialType(){return a.MeshBasicMaterial}extendParams(s,t,e){const n=[];s.color=new a.Color(1,1,1),s.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;s.color.fromArray(o),s.opacity=o[3]}i.baseColorTexture!==void 0&&n.push(e.assignTexture(s,"map",i.baseColorTexture,a.sRGBEncoding))}return Promise.all(n)}}class Fn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(s,t){const n=this.parser.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class Bn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_CLEARCOAT}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(e.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(e.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(e.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const r=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new a.Vector2(r,r)}return Promise.all(i)}}class Hn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_IRIDESCENCE}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.iridescenceFactor!==void 0&&(t.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&i.push(e.assignTexture(t,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(t.iridescenceIOR=o.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&i.push(e.assignTexture(t,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(i)}}class Un{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_SHEEN}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new a.Color(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=n.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(e.assignTexture(t,"sheenColorMap",o.sheenColorTexture,a.sRGBEncoding)),o.sheenRoughnessTexture!==void 0&&i.push(e.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class Vn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_TRANSMISSION}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(e.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class zn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_VOLUME}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(e.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||0;const r=o.attenuationColor||[1,1,1];return t.attenuationColor=new a.Color(r[0],r[1],r[2]),Promise.all(i)}}class Xn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_IOR}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const n=this.parser.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Yn{constructor(s){this.parser=s,this.name=I.KHR_MATERIALS_SPECULAR}getMaterialType(s){const e=this.parser.json.materials[s];return!e.extensions||!e.extensions[this.name]?null:a.MeshPhysicalMaterial}extendMaterialParams(s,t){const e=this.parser,n=e.json.materials[s];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],o=n.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(e.assignTexture(t,"specularIntensityMap",o.specularTexture));const r=o.specularColorFactor||[1,1,1];return t.specularColor=new a.Color(r[0],r[1],r[2]),o.specularColorTexture!==void 0&&i.push(e.assignTexture(t,"specularColorMap",o.specularColorTexture,a.sRGBEncoding)),Promise.all(i)}}class $n{constructor(s){this.parser=s,this.name=I.KHR_TEXTURE_BASISU}loadTexture(s){const t=this.parser,e=t.json,n=e.textures[s];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],o=t.options.ktx2Loader;if(!o){if(e.extensionsRequired&&e.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(s,i.source,o)}}class Zn{constructor(s){this.parser=s,this.name=I.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(s){const t=this.name,e=this.parser,n=e.json,i=n.textures[s];if(!i.extensions||!i.extensions[t])return null;const o=i.extensions[t],r=n.images[o.source];let c=e.textureLoader;if(r.uri){const u=e.options.manager.getHandler(r.uri);u!==null&&(c=u)}return this.detectSupport().then(function(u){if(u)return e.loadTextureImage(s,o.source,c);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return e.loadTexture(s)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(s){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){s(t.height===1)}})),this.isSupported}}class Kn{constructor(s){this.name=I.EXT_MESHOPT_COMPRESSION,this.parser=s}loadBufferView(s){const t=this.parser.json,e=t.bufferViews[s];if(e.extensions&&e.extensions[this.name]){const n=e.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,o.ready]).then(function(r){const c=n.byteOffset||0,u=n.byteLength||0,f=n.count,p=n.byteStride,m=new ArrayBuffer(f*p),h=new Uint8Array(r[0],c,u);return o.decodeGltfBuffer(new Uint8Array(m),f,p,h,n.mode,n.filter),m})}else return null}}const Ct="glTF",Ae=12,It={JSON:1313821514,BIN:5130562};class Qn{constructor(s){this.name=I.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(s,0,Ae);if(this.header={magic:a.LoaderUtils.decodeText(new Uint8Array(s.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==Ct)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const e=this.header.length-Ae,n=new DataView(s,Ae);let i=0;for(;i<e;){const o=n.getUint32(i,!0);i+=4;const r=n.getUint32(i,!0);if(i+=4,r===It.JSON){const c=new Uint8Array(s,Ae+i,o);this.content=a.LoaderUtils.decodeText(c)}else if(r===It.BIN){const c=Ae+i;this.body=s.slice(c,c+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class qn{constructor(s,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=I.KHR_DRACO_MESH_COMPRESSION,this.json=s,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(s,t){const e=this.json,n=this.dracoLoader,i=s.extensions[this.name].bufferView,o=s.extensions[this.name].attributes,r={},c={},u={};for(const f in o){const p=Ze[f]||f.toLowerCase();r[p]=o[f]}for(const f in s.attributes){const p=Ze[f]||f.toLowerCase();if(o[f]!==void 0){const m=e.accessors[s.attributes[f]],h=Le[m.componentType];u[p]=h,c[p]=m.normalized===!0}}return t.getDependency("bufferView",i).then(function(f){return new Promise(function(p){n.decodeDracoFile(f,function(m){for(const h in m.attributes){const w=m.attributes[h],_=c[h];_!==void 0&&(w.normalized=_)}p(m)},r,u)})})}}class Wn{constructor(){this.name=I.KHR_TEXTURE_TRANSFORM}extendTexture(s,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(s=s.clone(),t.offset!==void 0&&s.offset.fromArray(t.offset),t.rotation!==void 0&&(s.rotation=t.rotation),t.scale!==void 0&&s.repeat.fromArray(t.scale),s.needsUpdate=!0),s}}class Ye extends a.MeshStandardMaterial{constructor(s){super(),this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),e=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),n=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),r={specular:{value:new a.Color().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=r,this.onBeforeCompile=function(c){for(const u in r)c.uniforms[u]=r[u];c.fragmentShader=c.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",e).replace("#include <roughnessmap_fragment>",n).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return r.specular.value},set:function(c){r.specular.value=c}},specularMap:{get:function(){return r.specularMap.value},set:function(c){r.specularMap.value=c,c?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return r.glossiness.value},set:function(c){r.glossiness.value=c}},glossinessMap:{get:function(){return r.glossinessMap.value},set:function(c){r.glossinessMap.value=c,c?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(s)}copy(s){return super.copy(s),this.specularMap=s.specularMap,this.specular.copy(s.specular),this.glossinessMap=s.glossinessMap,this.glossiness=s.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class Jn{constructor(){this.name=I.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity"]}getMaterialType(){return Ye}extendParams(s,t,e){const n=t.extensions[this.name];s.color=new a.Color(1,1,1),s.opacity=1;const i=[];if(Array.isArray(n.diffuseFactor)){const o=n.diffuseFactor;s.color.fromArray(o),s.opacity=o[3]}if(n.diffuseTexture!==void 0&&i.push(e.assignTexture(s,"map",n.diffuseTexture,a.sRGBEncoding)),s.emissive=new a.Color(0,0,0),s.glossiness=n.glossinessFactor!==void 0?n.glossinessFactor:1,s.specular=new a.Color(1,1,1),Array.isArray(n.specularFactor)&&s.specular.fromArray(n.specularFactor),n.specularGlossinessTexture!==void 0){const o=n.specularGlossinessTexture;i.push(e.assignTexture(s,"glossinessMap",o)),i.push(e.assignTexture(s,"specularMap",o,a.sRGBEncoding))}return Promise.all(i)}createMaterial(s){const t=new Ye(s);return t.fog=!0,t.color=s.color,t.map=s.map===void 0?null:s.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=s.aoMap===void 0?null:s.aoMap,t.aoMapIntensity=1,t.emissive=s.emissive,t.emissiveIntensity=s.emissiveIntensity===void 0?1:s.emissiveIntensity,t.emissiveMap=s.emissiveMap===void 0?null:s.emissiveMap,t.bumpMap=s.bumpMap===void 0?null:s.bumpMap,t.bumpScale=1,t.normalMap=s.normalMap===void 0?null:s.normalMap,t.normalMapType=a.TangentSpaceNormalMap,s.normalScale&&(t.normalScale=s.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=s.specularMap===void 0?null:s.specularMap,t.specular=s.specular,t.glossinessMap=s.glossinessMap===void 0?null:s.glossinessMap,t.glossiness=s.glossiness,t.alphaMap=null,t.envMap=s.envMap===void 0?null:s.envMap,t.envMapIntensity=1,t}}class es{constructor(){this.name=I.KHR_MESH_QUANTIZATION}}class $e extends a.Interpolant{constructor(s,t,e,n){super(s,t,e,n)}copySampleValue_(s){const t=this.resultBuffer,e=this.sampleValues,n=this.valueSize,i=s*n*3+n;for(let o=0;o!==n;o++)t[o]=e[i+o];return t}}$e.prototype.interpolate_=function(l,s,t,e){const n=this.resultBuffer,i=this.sampleValues,o=this.valueSize,r=o*2,c=o*3,u=e-s,f=(t-s)/u,p=f*f,m=p*f,h=l*c,w=h-c,_=-2*m+3*p,E=m-p,y=1-_,S=E-p+f;for(let T=0;T!==o;T++){const A=i[w+T+o],x=i[w+T+r]*u,v=i[h+T+o],j=i[h+T]*u;n[T]=y*A+S*x+_*v+E*j}return n};const ts=new a.Quaternion;class ns extends $e{interpolate_(s,t,e,n){const i=super.interpolate_(s,t,e,n);return ts.fromArray(i).normalize().toArray(i),i}}const re={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Le={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Ot={9728:a.NearestFilter,9729:a.LinearFilter,9984:a.NearestMipmapNearestFilter,9985:a.LinearMipmapNearestFilter,9986:a.NearestMipmapLinearFilter,9987:a.LinearMipmapLinearFilter},vt={33071:a.ClampToEdgeWrapping,33648:a.MirroredRepeatWrapping,10497:a.RepeatWrapping},Gt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ze={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},pe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},ss={CUBICSPLINE:void 0,LINEAR:a.InterpolateLinear,STEP:a.InterpolateDiscrete},Ke={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function os(l){return l.DefaultMaterial===void 0&&(l.DefaultMaterial=new a.MeshStandardMaterial({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:a.FrontSide})),l.DefaultMaterial}function Pe(l,s,t){for(const e in t.extensions)l[e]===void 0&&(s.userData.gltfExtensions=s.userData.gltfExtensions||{},s.userData.gltfExtensions[e]=t.extensions[e])}function we(l,s){s.extras!==void 0&&(typeof s.extras=="object"?Object.assign(l.userData,s.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+s.extras))}function is(l,s,t){let e=!1,n=!1,i=!1;for(let u=0,f=s.length;u<f;u++){const p=s[u];if(p.POSITION!==void 0&&(e=!0),p.NORMAL!==void 0&&(n=!0),p.COLOR_0!==void 0&&(i=!0),e&&n&&i)break}if(!e&&!n&&!i)return Promise.resolve(l);const o=[],r=[],c=[];for(let u=0,f=s.length;u<f;u++){const p=s[u];if(e){const m=p.POSITION!==void 0?t.getDependency("accessor",p.POSITION):l.attributes.position;o.push(m)}if(n){const m=p.NORMAL!==void 0?t.getDependency("accessor",p.NORMAL):l.attributes.normal;r.push(m)}if(i){const m=p.COLOR_0!==void 0?t.getDependency("accessor",p.COLOR_0):l.attributes.color;c.push(m)}}return Promise.all([Promise.all(o),Promise.all(r),Promise.all(c)]).then(function(u){const f=u[0],p=u[1],m=u[2];return e&&(l.morphAttributes.position=f),n&&(l.morphAttributes.normal=p),i&&(l.morphAttributes.color=m),l.morphTargetsRelative=!0,l})}function as(l,s){if(l.updateMorphTargets(),s.weights!==void 0)for(let t=0,e=s.weights.length;t<e;t++)l.morphTargetInfluences[t]=s.weights[t];if(s.extras&&Array.isArray(s.extras.targetNames)){const t=s.extras.targetNames;if(l.morphTargetInfluences.length===t.length){l.morphTargetDictionary={};for(let e=0,n=t.length;e<n;e++)l.morphTargetDictionary[t[e]]=e}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function rs(l){const s=l.extensions&&l.extensions[I.KHR_DRACO_MESH_COMPRESSION];let t;return s?t="draco:"+s.bufferView+":"+s.indices+":"+jt(s.attributes):t=l.indices+":"+jt(l.attributes)+":"+l.mode,t}function jt(l){let s="";const t=Object.keys(l).sort();for(let e=0,n=t.length;e<n;e++)s+=t[e]+":"+l[t[e]]+";";return s}function Qe(l){switch(l){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function cs(l){return l.search(/\.jpe?g($|\?)/i)>0||l.search(/^data\:image\/jpeg/)===0?"image/jpeg":l.search(/\.webp($|\?)/i)>0||l.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}class ls{constructor(s={},t={}){this.json=s,this.extensions={},this.plugins={},this.options=t,this.cache=new Nn,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};const e=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,n=navigator.userAgent.indexOf("Firefox")>-1,i=n?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1;typeof createImageBitmap>"u"||e||n&&i<98?this.textureLoader=new a.TextureLoader(this.options.manager):this.textureLoader=new a.ImageBitmapLoader(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new a.FileLoader(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(s){this.extensions=s}setPlugins(s){this.plugins=s}parse(s,t){const e=this,n=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([e.getDependencies("scene"),e.getDependencies("animation"),e.getDependencies("camera")])}).then(function(o){const r={scene:o[0][n.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:n.asset,parser:e,userData:{}};Pe(i,r,n),we(r,n),Promise.all(e._invokeAll(function(c){return c.afterRoot&&c.afterRoot(r)})).then(function(){s(r)})}).catch(t)}_markDefs(){const s=this.json.nodes||[],t=this.json.skins||[],e=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const o=t[n].joints;for(let r=0,c=o.length;r<c;r++)s[o[r]].isBone=!0}for(let n=0,i=s.length;n<i;n++){const o=s[n];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(e[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(s,t){t!==void 0&&(s.refs[t]===void 0&&(s.refs[t]=s.uses[t]=0),s.refs[t]++)}_getNodeRef(s,t,e){if(s.refs[t]<=1)return e;const n=e.clone(),i=(o,r)=>{const c=this.associations.get(o);c!=null&&this.associations.set(r,c);for(const[u,f]of o.children.entries())i(f,r.children[u])};return i(e,n),n.name+="_instance_"+s.uses[t]++,n}_invokeOne(s){const t=Object.values(this.plugins);t.push(this);for(let e=0;e<t.length;e++){const n=s(t[e]);if(n)return n}return null}_invokeAll(s){const t=Object.values(this.plugins);t.unshift(this);const e=[];for(let n=0;n<t.length;n++){const i=s(t[n]);i&&e.push(i)}return e}getDependency(s,t){const e=s+":"+t;let n=this.cache.get(e);if(!n){switch(s){case"scene":n=this.loadScene(t);break;case"node":n=this.loadNode(t);break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:throw new Error("Unknown type: "+s)}this.cache.add(e,n)}return n}getDependencies(s){let t=this.cache.get(s);if(!t){const e=this,n=this.json[s+(s==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,o){return e.getDependency(s,o)})),this.cache.add(s,t)}return t}loadBuffer(s){const t=this.json.buffers[s],e=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&s===0)return Promise.resolve(this.extensions[I.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,o){e.load(a.LoaderUtils.resolveURL(t.uri,n.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(s){const t=this.json.bufferViews[s];return this.getDependency("buffer",t.buffer).then(function(e){const n=t.byteLength||0,i=t.byteOffset||0;return e.slice(i,i+n)})}loadAccessor(s){const t=this,e=this.json,n=this.json.accessors[s];if(n.bufferView===void 0&&n.sparse===void 0)return Promise.resolve(null);const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(o){const r=o[0],c=Gt[n.type],u=Le[n.componentType],f=u.BYTES_PER_ELEMENT,p=f*c,m=n.byteOffset||0,h=n.bufferView!==void 0?e.bufferViews[n.bufferView].byteStride:void 0,w=n.normalized===!0;let _,E;if(h&&h!==p){const y=Math.floor(m/h),S="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+y+":"+n.count;let T=t.cache.get(S);T||(_=new u(r,y*h,n.count*h/f),T=new a.InterleavedBuffer(_,h/f),t.cache.add(S,T)),E=new a.InterleavedBufferAttribute(T,c,m%h/f,w)}else r===null?_=new u(n.count*c):_=new u(r,m,n.count*c),E=new a.BufferAttribute(_,c,w);if(n.sparse!==void 0){const y=Gt.SCALAR,S=Le[n.sparse.indices.componentType],T=n.sparse.indices.byteOffset||0,A=n.sparse.values.byteOffset||0,x=new S(o[1],T,n.sparse.count*y),v=new u(o[2],A,n.sparse.count*c);r!==null&&(E=new a.BufferAttribute(E.array.slice(),E.itemSize,E.normalized));for(let j=0,G=x.length;j<G;j++){const V=x[j];if(E.setX(V,v[j*c]),c>=2&&E.setY(V,v[j*c+1]),c>=3&&E.setZ(V,v[j*c+2]),c>=4&&E.setW(V,v[j*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return E})}loadTexture(s){const t=this.json,e=this.options,i=t.textures[s].source,o=t.images[i];let r=this.textureLoader;if(o.uri){const c=e.manager.getHandler(o.uri);c!==null&&(r=c)}return this.loadTextureImage(s,i,r)}loadTextureImage(s,t,e){const n=this,i=this.json,o=i.textures[s],r=i.images[t],c=(r.uri||r.bufferView)+":"+o.sampler;if(this.textureCache[c])return this.textureCache[c];const u=this.loadImageSource(t,e).then(function(f){f.flipY=!1,o.name&&(f.name=o.name);const m=(i.samplers||{})[o.sampler]||{};return f.magFilter=Ot[m.magFilter]||a.LinearFilter,f.minFilter=Ot[m.minFilter]||a.LinearMipmapLinearFilter,f.wrapS=vt[m.wrapS]||a.RepeatWrapping,f.wrapT=vt[m.wrapT]||a.RepeatWrapping,n.associations.set(f,{textures:s}),f}).catch(function(){return null});return this.textureCache[c]=u,u}loadImageSource(s,t){const e=this,n=this.json,i=this.options;if(this.sourceCache[s]!==void 0)return this.sourceCache[s].then(p=>p.clone());const o=n.images[s],r=self.URL||self.webkitURL;let c=o.uri||"",u=!1;if(o.bufferView!==void 0)c=e.getDependency("bufferView",o.bufferView).then(function(p){u=!0;const m=new Blob([p],{type:o.mimeType});return c=r.createObjectURL(m),c});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+s+" is missing URI and bufferView");const f=Promise.resolve(c).then(function(p){return new Promise(function(m,h){let w=m;t.isImageBitmapLoader===!0&&(w=function(_){const E=new a.Texture(_);E.needsUpdate=!0,m(E)}),t.load(a.LoaderUtils.resolveURL(p,i.path),w,void 0,h)})}).then(function(p){return u===!0&&r.revokeObjectURL(c),p.userData.mimeType=o.mimeType||cs(o.uri),p}).catch(function(p){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),p});return this.sourceCache[s]=f,f}assignTexture(s,t,e,n){const i=this;return this.getDependency("texture",e.index).then(function(o){if(e.texCoord!==void 0&&e.texCoord!=0&&!(t==="aoMap"&&e.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+e.texCoord+" for texture "+t+" not yet supported."),i.extensions[I.KHR_TEXTURE_TRANSFORM]){const r=e.extensions!==void 0?e.extensions[I.KHR_TEXTURE_TRANSFORM]:void 0;if(r){const c=i.associations.get(o);o=i.extensions[I.KHR_TEXTURE_TRANSFORM].extendTexture(o,r),i.associations.set(o,c)}}return n!==void 0&&(o.encoding=n),s[t]=o,o})}assignFinalMaterial(s){const t=s.geometry;let e=s.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(s.isPoints){const r="PointsMaterial:"+e.uuid;let c=this.cache.get(r);c||(c=new a.PointsMaterial,a.Material.prototype.copy.call(c,e),c.color.copy(e.color),c.map=e.map,c.sizeAttenuation=!1,this.cache.add(r,c)),e=c}else if(s.isLine){const r="LineBasicMaterial:"+e.uuid;let c=this.cache.get(r);c||(c=new a.LineBasicMaterial,a.Material.prototype.copy.call(c,e),c.color.copy(e.color),this.cache.add(r,c)),e=c}if(n||i||o){let r="ClonedMaterial:"+e.uuid+":";e.isGLTFSpecularGlossinessMaterial&&(r+="specular-glossiness:"),n&&(r+="derivative-tangents:"),i&&(r+="vertex-colors:"),o&&(r+="flat-shading:");let c=this.cache.get(r);c||(c=e.clone(),i&&(c.vertexColors=!0),o&&(c.flatShading=!0),n&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(r,c),this.associations.set(c,this.associations.get(e))),e=c}e.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),s.material=e}getMaterialType(){return a.MeshStandardMaterial}loadMaterial(s){const t=this,e=this.json,n=this.extensions,i=e.materials[s];let o;const r={},c=i.extensions||{},u=[];if(c[I.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const p=n[I.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];o=p.getMaterialType(),u.push(p.extendParams(r,i,t))}else if(c[I.KHR_MATERIALS_UNLIT]){const p=n[I.KHR_MATERIALS_UNLIT];o=p.getMaterialType(),u.push(p.extendParams(r,i,t))}else{const p=i.pbrMetallicRoughness||{};if(r.color=new a.Color(1,1,1),r.opacity=1,Array.isArray(p.baseColorFactor)){const m=p.baseColorFactor;r.color.fromArray(m),r.opacity=m[3]}p.baseColorTexture!==void 0&&u.push(t.assignTexture(r,"map",p.baseColorTexture,a.sRGBEncoding)),r.metalness=p.metallicFactor!==void 0?p.metallicFactor:1,r.roughness=p.roughnessFactor!==void 0?p.roughnessFactor:1,p.metallicRoughnessTexture!==void 0&&(u.push(t.assignTexture(r,"metalnessMap",p.metallicRoughnessTexture)),u.push(t.assignTexture(r,"roughnessMap",p.metallicRoughnessTexture))),o=this._invokeOne(function(m){return m.getMaterialType&&m.getMaterialType(s)}),u.push(Promise.all(this._invokeAll(function(m){return m.extendMaterialParams&&m.extendMaterialParams(s,r)})))}i.doubleSided===!0&&(r.side=a.DoubleSide);const f=i.alphaMode||Ke.OPAQUE;if(f===Ke.BLEND?(r.transparent=!0,r.depthWrite=!1):(r.transparent=!1,f===Ke.MASK&&(r.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==a.MeshBasicMaterial&&(u.push(t.assignTexture(r,"normalMap",i.normalTexture)),r.normalScale=new a.Vector2(1,1),i.normalTexture.scale!==void 0)){const p=i.normalTexture.scale;r.normalScale.set(p,p)}return i.occlusionTexture!==void 0&&o!==a.MeshBasicMaterial&&(u.push(t.assignTexture(r,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(r.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==a.MeshBasicMaterial&&(r.emissive=new a.Color().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&o!==a.MeshBasicMaterial&&u.push(t.assignTexture(r,"emissiveMap",i.emissiveTexture,a.sRGBEncoding)),Promise.all(u).then(function(){let p;return o===Ye?p=n[I.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(r):p=new o(r),i.name&&(p.name=i.name),we(p,i),t.associations.set(p,{materials:s}),i.extensions&&Pe(n,p,i),p})}createUniqueName(s){const t=a.PropertyBinding.sanitizeNodeName(s||"");let e=t;for(let n=1;this.nodeNamesUsed[e];++n)e=t+"_"+n;return this.nodeNamesUsed[e]=!0,e}loadGeometries(s){const t=this,e=this.extensions,n=this.primitiveCache;function i(r){return e[I.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(r,t).then(function(c){return Dt(c,r,t)})}const o=[];for(let r=0,c=s.length;r<c;r++){const u=s[r],f=rs(u),p=n[f];if(p)o.push(p.promise);else{let m;u.extensions&&u.extensions[I.KHR_DRACO_MESH_COMPRESSION]?m=i(u):m=Dt(new a.BufferGeometry,u,t),n[f]={primitive:u,promise:m},o.push(m)}}return Promise.all(o)}loadMesh(s){const t=this,e=this.json,n=this.extensions,i=e.meshes[s],o=i.primitives,r=[];for(let c=0,u=o.length;c<u;c++){const f=o[c].material===void 0?os(this.cache):this.getDependency("material",o[c].material);r.push(f)}return r.push(t.loadGeometries(o)),Promise.all(r).then(function(c){const u=c.slice(0,c.length-1),f=c[c.length-1],p=[];for(let h=0,w=f.length;h<w;h++){const _=f[h],E=o[h];let y;const S=u[h];if(E.mode===re.TRIANGLES||E.mode===re.TRIANGLE_STRIP||E.mode===re.TRIANGLE_FAN||E.mode===void 0)y=i.isSkinnedMesh===!0?new a.SkinnedMesh(_,S):new a.Mesh(_,S),y.isSkinnedMesh===!0&&!y.geometry.attributes.skinWeight.normalized&&y.normalizeSkinWeights(),E.mode===re.TRIANGLE_STRIP?y.geometry=kt(y.geometry,a.TriangleStripDrawMode):E.mode===re.TRIANGLE_FAN&&(y.geometry=kt(y.geometry,a.TriangleFanDrawMode));else if(E.mode===re.LINES)y=new a.LineSegments(_,S);else if(E.mode===re.LINE_STRIP)y=new a.Line(_,S);else if(E.mode===re.LINE_LOOP)y=new a.LineLoop(_,S);else if(E.mode===re.POINTS)y=new a.Points(_,S);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+E.mode);Object.keys(y.geometry.morphAttributes).length>0&&as(y,i),y.name=t.createUniqueName(i.name||"mesh_"+s),we(y,i),E.extensions&&Pe(n,y,E),t.assignFinalMaterial(y),p.push(y)}for(let h=0,w=p.length;h<w;h++)t.associations.set(p[h],{meshes:s,primitives:h});if(p.length===1)return p[0];const m=new a.Group;t.associations.set(m,{meshes:s});for(let h=0,w=p.length;h<w;h++)m.add(p[h]);return m})}loadCamera(s){let t;const e=this.json.cameras[s],n=e[e.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return e.type==="perspective"?t=new a.PerspectiveCamera(a.MathUtils.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):e.type==="orthographic"&&(t=new a.OrthographicCamera(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),e.name&&(t.name=this.createUniqueName(e.name)),we(t,e),Promise.resolve(t)}loadSkin(s){const t=this.json.skins[s],e={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(e):this.getDependency("accessor",t.inverseBindMatrices).then(function(n){return e.inverseBindMatrices=n,e})}loadAnimation(s){const e=this.json.animations[s],n=[],i=[],o=[],r=[],c=[];for(let u=0,f=e.channels.length;u<f;u++){const p=e.channels[u],m=e.samplers[p.sampler],h=p.target,w=h.node!==void 0?h.node:h.id,_=e.parameters!==void 0?e.parameters[m.input]:m.input,E=e.parameters!==void 0?e.parameters[m.output]:m.output;n.push(this.getDependency("node",w)),i.push(this.getDependency("accessor",_)),o.push(this.getDependency("accessor",E)),r.push(m),c.push(h)}return Promise.all([Promise.all(n),Promise.all(i),Promise.all(o),Promise.all(r),Promise.all(c)]).then(function(u){const f=u[0],p=u[1],m=u[2],h=u[3],w=u[4],_=[];for(let y=0,S=f.length;y<S;y++){const T=f[y],A=p[y],x=m[y],v=h[y],j=w[y];if(T===void 0)continue;T.updateMatrix(),T.matrixAutoUpdate=!0;let G;switch(pe[j.path]){case pe.weights:G=a.NumberKeyframeTrack;break;case pe.rotation:G=a.QuaternionKeyframeTrack;break;case pe.position:case pe.scale:default:G=a.VectorKeyframeTrack;break}const V=T.name?T.name:T.uuid,O=v.interpolation!==void 0?ss[v.interpolation]:a.InterpolateLinear,B=[];pe[j.path]===pe.weights?T.traverse(function(F){F.morphTargetInfluences&&B.push(F.name?F.name:F.uuid)}):B.push(V);let Q=x.array;if(x.normalized){const F=Qe(Q.constructor),H=new Float32Array(Q.length);for(let D=0,J=Q.length;D<J;D++)H[D]=Q[D]*F;Q=H}for(let F=0,H=B.length;F<H;F++){const D=new G(B[F]+"."+pe[j.path],A.array,Q,O);v.interpolation==="CUBICSPLINE"&&(D.createInterpolant=function(Y){const q=this instanceof a.QuaternionKeyframeTrack?ns:$e;return new q(this.times,this.values,this.getValueSize()/3,Y)},D.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),_.push(D)}}const E=e.name?e.name:"animation_"+s;return new a.AnimationClip(E,void 0,_)})}createNodeMesh(s){const t=this.json,e=this,n=t.nodes[s];return n.mesh===void 0?null:e.getDependency("mesh",n.mesh).then(function(i){const o=e._getNodeRef(e.meshCache,n.mesh,i);return n.weights!==void 0&&o.traverse(function(r){if(r.isMesh)for(let c=0,u=n.weights.length;c<u;c++)r.morphTargetInfluences[c]=n.weights[c]}),o})}loadNode(s){const t=this.json,e=this.extensions,n=this,i=t.nodes[s],o=i.name?n.createUniqueName(i.name):"";return function(){const r=[],c=n._invokeOne(function(u){return u.createNodeMesh&&u.createNodeMesh(s)});return c&&r.push(c),i.camera!==void 0&&r.push(n.getDependency("camera",i.camera).then(function(u){return n._getNodeRef(n.cameraCache,i.camera,u)})),n._invokeAll(function(u){return u.createNodeAttachment&&u.createNodeAttachment(s)}).forEach(function(u){r.push(u)}),Promise.all(r)}().then(function(r){let c;if(i.isBone===!0?c=new a.Bone:r.length>1?c=new a.Group:r.length===1?c=r[0]:c=new a.Object3D,c!==r[0])for(let u=0,f=r.length;u<f;u++)c.add(r[u]);if(i.name&&(c.userData.name=i.name,c.name=o),we(c,i),i.extensions&&Pe(e,c,i),i.matrix!==void 0){const u=new a.Matrix4;u.fromArray(i.matrix),c.applyMatrix4(u)}else i.translation!==void 0&&c.position.fromArray(i.translation),i.rotation!==void 0&&c.quaternion.fromArray(i.rotation),i.scale!==void 0&&c.scale.fromArray(i.scale);return n.associations.has(c)||n.associations.set(c,{}),n.associations.get(c).nodes=s,c})}loadScene(s){const t=this.json,e=this.extensions,n=this.json.scenes[s],i=this,o=new a.Group;n.name&&(o.name=i.createUniqueName(n.name)),we(o,n),n.extensions&&Pe(e,o,n);const r=n.nodes||[],c=[];for(let u=0,f=r.length;u<f;u++)c.push(Nt(r[u],o,t,i));return Promise.all(c).then(function(){const u=f=>{const p=new Map;for(const[m,h]of i.associations)(m instanceof a.Material||m instanceof a.Texture)&&p.set(m,h);return f.traverse(m=>{const h=i.associations.get(m);h!=null&&p.set(m,h)}),p};return i.associations=u(o),o})}}function Nt(l,s,t,e){const n=t.nodes[l];return e.getDependency("node",l).then(function(i){if(n.skin===void 0)return i;let o;return e.getDependency("skin",n.skin).then(function(r){o=r;const c=[];for(let u=0,f=o.joints.length;u<f;u++)c.push(e.getDependency("node",o.joints[u]));return Promise.all(c)}).then(function(r){return i.traverse(function(c){if(!c.isMesh)return;const u=[],f=[];for(let p=0,m=r.length;p<m;p++){const h=r[p];if(h){u.push(h);const w=new a.Matrix4;o.inverseBindMatrices!==void 0&&w.fromArray(o.inverseBindMatrices.array,p*16),f.push(w)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[p])}c.bind(new a.Skeleton(u,f),c.matrixWorld)}),i})}).then(function(i){s.add(i);const o=[];if(n.children){const r=n.children;for(let c=0,u=r.length;c<u;c++){const f=r[c];o.push(Nt(f,i,t,e))}}return Promise.all(o)})}function us(l,s,t){const e=s.attributes,n=new a.Box3;if(e.POSITION!==void 0){const r=t.json.accessors[e.POSITION],c=r.min,u=r.max;if(c!==void 0&&u!==void 0){if(n.set(new a.Vector3(c[0],c[1],c[2]),new a.Vector3(u[0],u[1],u[2])),r.normalized){const f=Qe(Le[r.componentType]);n.min.multiplyScalar(f),n.max.multiplyScalar(f)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=s.targets;if(i!==void 0){const r=new a.Vector3,c=new a.Vector3;for(let u=0,f=i.length;u<f;u++){const p=i[u];if(p.POSITION!==void 0){const m=t.json.accessors[p.POSITION],h=m.min,w=m.max;if(h!==void 0&&w!==void 0){if(c.setX(Math.max(Math.abs(h[0]),Math.abs(w[0]))),c.setY(Math.max(Math.abs(h[1]),Math.abs(w[1]))),c.setZ(Math.max(Math.abs(h[2]),Math.abs(w[2]))),m.normalized){const _=Qe(Le[m.componentType]);c.multiplyScalar(_)}r.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(r)}l.boundingBox=n;const o=new a.Sphere;n.getCenter(o.center),o.radius=n.min.distanceTo(n.max)/2,l.boundingSphere=o}function Dt(l,s,t){const e=s.attributes,n=[];function i(o,r){return t.getDependency("accessor",o).then(function(c){l.setAttribute(r,c)})}for(const o in e){const r=Ze[o]||o.toLowerCase();r in l.attributes||n.push(i(e[o],r))}if(s.indices!==void 0&&!l.index){const o=t.getDependency("accessor",s.indices).then(function(r){l.setIndex(r)});n.push(o)}return we(l,s),us(l,s,t),Promise.all(n).then(function(){return s.targets!==void 0?is(l,s.targets,t):l})}function kt(l,s){let t=l.getIndex();if(t===null){const o=[],r=l.getAttribute("position");if(r!==void 0){for(let c=0;c<r.count;c++)o.push(c);l.setIndex(o),t=l.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),l}const e=t.count-2,n=[];if(s===a.TriangleFanDrawMode)for(let o=1;o<=e;o++)n.push(t.getX(0)),n.push(t.getX(o)),n.push(t.getX(o+1));else for(let o=0;o<e;o++)o%2===0?(n.push(t.getX(o)),n.push(t.getX(o+1)),n.push(t.getX(o+2))):(n.push(t.getX(o+2)),n.push(t.getX(o+1)),n.push(t.getX(o)));n.length/3!==e&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=l.clone();return i.setIndex(n),i}const Ft=d.defineComponent({__name:"GLTFLoader",props:{castShadow:{type:Boolean,default:!1},enableRaycasting:{type:Boolean,default:!1},position:{default:()=>[0,0,0]},receiveShadow:{type:Boolean,default:!1},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]},url:null},emits:["load","progress","error","click","mousemove","mouseenter","mouseleave"],setup(l,{expose:s,emit:t}){const e=l,n=new jn,i=new a.Group;i.castShadow=!0,i.receiveShadow=!0,ae(i),C(e,"position",i),C(e,"rotation",i),C(e,"scale",i);function o(){n.load(e.url,function(c){C(e,"position",i,!1),C(e,"rotation",i,!1),C(e,"scale",i,!1),i.add(c.scene),r(),t("load",c.scene)},function(c){t("progress",c)},function(c){t("error",c)})}function r(){if(i.children.length!==0)for(const c of i.children[0].children)c.castShadow=e.castShadow,c.receiveShadow=e.receiveShadow}return r(),d.watch(()=>e.url,()=>o(),{immediate:!0}),Fe(i.children,e,t),d.provide("mesh",i),s({three:i}),(c,u)=>d.renderSlot(c.$slots,"default")}}),ds=/^[og]\s*(.+)?/,ps=/^mtllib /,fs=/^usemtl /,ms=/^usemap /,Bt=new a.Vector3,qe=new a.Vector3,Ht=new a.Vector3,Ut=new a.Vector3,W=new a.Vector3,je=new a.Color;function hs(){const l={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(s,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=s,this.object.fromDeclaration=t!==!1;return}const e=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:s||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,i){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const r={index:this.materials.length,name:n||"",mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(c){const u={index:typeof c=="number"?c:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return u.clone=this.clone.bind(u),u}};return this.materials.push(r),r},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),n&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}},e&&e.name&&typeof e.clone=="function"){const n=e.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(s,t){const e=parseInt(s,10);return(e>=0?e-1:e+t/3)*3},parseNormalIndex:function(s,t){const e=parseInt(s,10);return(e>=0?e-1:e+t/3)*3},parseUVIndex:function(s,t){const e=parseInt(s,10);return(e>=0?e-1:e+t/2)*2},addVertex:function(s,t,e){const n=this.vertices,i=this.object.geometry.vertices;i.push(n[s+0],n[s+1],n[s+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[e+0],n[e+1],n[e+2])},addVertexPoint:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addVertexLine:function(s){const t=this.vertices;this.object.geometry.vertices.push(t[s+0],t[s+1],t[s+2])},addNormal:function(s,t,e){const n=this.normals,i=this.object.geometry.normals;i.push(n[s+0],n[s+1],n[s+2]),i.push(n[t+0],n[t+1],n[t+2]),i.push(n[e+0],n[e+1],n[e+2])},addFaceNormal:function(s,t,e){const n=this.vertices,i=this.object.geometry.normals;Bt.fromArray(n,s),qe.fromArray(n,t),Ht.fromArray(n,e),W.subVectors(Ht,qe),Ut.subVectors(Bt,qe),W.cross(Ut),W.normalize(),i.push(W.x,W.y,W.z),i.push(W.x,W.y,W.z),i.push(W.x,W.y,W.z)},addColor:function(s,t,e){const n=this.colors,i=this.object.geometry.colors;n[s]!==void 0&&i.push(n[s+0],n[s+1],n[s+2]),n[t]!==void 0&&i.push(n[t+0],n[t+1],n[t+2]),n[e]!==void 0&&i.push(n[e+0],n[e+1],n[e+2])},addUV:function(s,t,e){const n=this.uvs,i=this.object.geometry.uvs;i.push(n[s+0],n[s+1]),i.push(n[t+0],n[t+1]),i.push(n[e+0],n[e+1])},addDefaultUV:function(){const s=this.object.geometry.uvs;s.push(0,0),s.push(0,0),s.push(0,0)},addUVLine:function(s){const t=this.uvs;this.object.geometry.uvs.push(t[s+0],t[s+1])},addFace:function(s,t,e,n,i,o,r,c,u){const f=this.vertices.length;let p=this.parseVertexIndex(s,f),m=this.parseVertexIndex(t,f),h=this.parseVertexIndex(e,f);if(this.addVertex(p,m,h),this.addColor(p,m,h),r!==void 0&&r!==""){const w=this.normals.length;p=this.parseNormalIndex(r,w),m=this.parseNormalIndex(c,w),h=this.parseNormalIndex(u,w),this.addNormal(p,m,h)}else this.addFaceNormal(p,m,h);if(n!==void 0&&n!==""){const w=this.uvs.length;p=this.parseUVIndex(n,w),m=this.parseUVIndex(i,w),h=this.parseUVIndex(o,w),this.addUV(p,m,h),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(s){this.object.geometry.type="Points";const t=this.vertices.length;for(let e=0,n=s.length;e<n;e++){const i=this.parseVertexIndex(s[e],t);this.addVertexPoint(i),this.addColor(i)}},addLineGeometry:function(s,t){this.object.geometry.type="Line";const e=this.vertices.length,n=this.uvs.length;for(let i=0,o=s.length;i<o;i++)this.addVertexLine(this.parseVertexIndex(s[i],e));for(let i=0,o=t.length;i<o;i++)this.addUVLine(this.parseUVIndex(t[i],n))}};return l.startObject("",!1),l}class gs extends a.Loader{constructor(s){super(s),this.materials=null}load(s,t,e,n){const i=this,o=new a.FileLoader(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(s,function(r){try{t(i.parse(r))}catch(c){n?n(c):console.error(c),i.manager.itemError(s)}},e,n)}setMaterials(s){return this.materials=s,this}parse(s){const t=new hs;s.indexOf(`\r
`)!==-1&&(s=s.replace(/\r\n/g,`
`)),s.indexOf(`\\
`)!==-1&&(s=s.replace(/\\\n/g,""));const e=s.split(`
`);let n="",i="",o=0,r=[];const c=typeof"".trimLeft=="function";for(let p=0,m=e.length;p<m;p++)if(n=e[p],n=c?n.trimLeft():n.trim(),o=n.length,o!==0&&(i=n.charAt(0),i!=="#"))if(i==="v"){const h=n.split(/\s+/);switch(h[0]){case"v":t.vertices.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),h.length>=7?(je.setRGB(parseFloat(h[4]),parseFloat(h[5]),parseFloat(h[6])).convertSRGBToLinear(),t.colors.push(je.r,je.g,je.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3]));break;case"vt":t.uvs.push(parseFloat(h[1]),parseFloat(h[2]));break}}else if(i==="f"){const w=n.slice(1).trim().split(/\s+/),_=[];for(let y=0,S=w.length;y<S;y++){const T=w[y];if(T.length>0){const A=T.split("/");_.push(A)}}const E=_[0];for(let y=1,S=_.length-1;y<S;y++){const T=_[y],A=_[y+1];t.addFace(E[0],T[0],A[0],E[1],T[1],A[1],E[2],T[2],A[2])}}else if(i==="l"){const h=n.substring(1).trim().split(" ");let w=[];const _=[];if(n.indexOf("/")===-1)w=h;else for(let E=0,y=h.length;E<y;E++){const S=h[E].split("/");S[0]!==""&&w.push(S[0]),S[1]!==""&&_.push(S[1])}t.addLineGeometry(w,_)}else if(i==="p"){const w=n.slice(1).trim().split(" ");t.addPointGeometry(w)}else if((r=ds.exec(n))!==null){const h=(" "+r[0].slice(1).trim()).slice(1);t.startObject(h)}else if(fs.test(n))t.object.startMaterial(n.substring(7).trim(),t.materialLibraries);else if(ps.test(n))t.materialLibraries.push(n.substring(7).trim());else if(ms.test(n))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(i==="s"){if(r=n.split(" "),r.length>1){const w=r[1].trim().toLowerCase();t.object.smooth=w!=="0"&&w!=="off"}else t.object.smooth=!0;const h=t.object.currentMaterial();h&&(h.smooth=t.object.smooth)}else{if(n==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+n+'"')}t.finalize();const u=new a.Group;if(u.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let p=0,m=t.objects.length;p<m;p++){const h=t.objects[p],w=h.geometry,_=h.materials,E=w.type==="Line",y=w.type==="Points";let S=!1;if(w.vertices.length===0)continue;const T=new a.BufferGeometry;T.setAttribute("position",new a.Float32BufferAttribute(w.vertices,3)),w.normals.length>0&&T.setAttribute("normal",new a.Float32BufferAttribute(w.normals,3)),w.colors.length>0&&(S=!0,T.setAttribute("color",new a.Float32BufferAttribute(w.colors,3))),w.hasUVIndices===!0&&T.setAttribute("uv",new a.Float32BufferAttribute(w.uvs,2));const A=[];for(let v=0,j=_.length;v<j;v++){const G=_[v],V=G.name+"_"+G.smooth+"_"+S;let O=t.materials[V];if(this.materials!==null){if(O=this.materials.create(G.name),E&&O&&!(O instanceof a.LineBasicMaterial)){const B=new a.LineBasicMaterial;a.Material.prototype.copy.call(B,O),B.color.copy(O.color),O=B}else if(y&&O&&!(O instanceof a.PointsMaterial)){const B=new a.PointsMaterial({size:10,sizeAttenuation:!1});a.Material.prototype.copy.call(B,O),B.color.copy(O.color),B.map=O.map,O=B}}O===void 0&&(E?O=new a.LineBasicMaterial:y?O=new a.PointsMaterial({size:1,sizeAttenuation:!1}):O=new a.MeshPhongMaterial,O.name=G.name,O.flatShading=!G.smooth,O.vertexColors=S,t.materials[V]=O),A.push(O)}let x;if(A.length>1){for(let v=0,j=_.length;v<j;v++){const G=_[v];T.addGroup(G.groupStart,G.groupCount,v)}E?x=new a.LineSegments(T,A):y?x=new a.Points(T,A):x=new a.Mesh(T,A)}else E?x=new a.LineSegments(T,A[0]):y?x=new a.Points(T,A[0]):x=new a.Mesh(T,A[0]);x.name=h.name,u.add(x)}else if(t.vertices.length>0){const p=new a.PointsMaterial({size:1,sizeAttenuation:!1}),m=new a.BufferGeometry;m.setAttribute("position",new a.Float32BufferAttribute(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(m.setAttribute("color",new a.Float32BufferAttribute(t.colors,3)),p.vertexColors=!0);const h=new a.Points(m,p);u.add(h)}return u}}const Vt=d.defineComponent({__name:"OBJLoader",props:{castShadow:{type:Boolean,default:!1},enableRaycasting:{type:Boolean,default:!1},position:{default:()=>[0,0,0]},receiveShadow:{type:Boolean,default:!1},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]},url:null},emits:["load","progress","error","click","mousemove","mouseenter","mouseleave"],setup(l,{expose:s,emit:t}){const e=l,n=new gs,i=new a.Group;ae(i),C(e,"position",i),C(e,"rotation",i),C(e,"scale",i);function o(){n.load(e.url,function(c){for(const u of c.children)"material"in i&&(u.material=i.material);i.add(c),r(),t("load",c)},function(c){t("progress",c)},function(c){t("error",c)})}function r(){if(i.children.length!==0)for(const c of i.children[0].children)c.castShadow=e.castShadow,c.receiveShadow=e.receiveShadow}return r(),d.watch(()=>e.url,()=>o(),{immediate:!0}),Fe(i.children,e,t),d.provide("mesh",i),s({three:i}),(c,u)=>d.renderSlot(c.$slots,"default")}}),zt=d.defineComponent({__name:"AxesHelper",props:{position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},size:{default:1},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.AxesHelper(t.size);return e.add(n),C(t,"position",n),C(t,"rotation",n),C(t,"scale",n),d.provide("mesh",n),s({three:n}),(i,o)=>d.renderSlot(i.$slots,"default")}}),ys={name:"BoxGeometry",render:()=>null},Xt=d.defineComponent({...ys,props:{name:{default:""},width:{default:1},height:{default:1},depth:{default:1},widthSegments:{default:1},heightSegments:{default:1},depthSegments:{default:1}},setup(l,{expose:s}){const t=l;function e(c,u,f,p,m,h){return new a.BoxGeometry(c,u,f,p,m,h)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.width,t.height,t.depth,t.widthSegments,t.heightSegments,t.depthSegments);te(n,c)}return r(),b(t,"name",()=>{n.name=t.name}),b(t,"width",r),b(t,"height",r),b(t,"depth",r),b(t,"widthSegments",r),b(t,"heightSegments",r),b(t,"depthSegments",r),s({three:n}),{props:t,makeBox:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),ws={name:"BufferGeometry",render:()=>null},Yt=d.defineComponent({...ws,props:{name:{default:""},vertices:{default:()=>[]},faces:{default:()=>[]},uvs:{default:()=>[]},normals:{type:[Array,Boolean],default:!1}},setup(l,{expose:s}){const t=l;function e(){const c=new a.BufferGeometry,u=new Float32Array(t.vertices);if(c.setAttribute("position",new a.BufferAttribute(u,3)),t.uvs.length>0){const f=new Float32Array(t.uvs);c.setAttribute("uv",new a.BufferAttribute(f,2))}if(t.normals===!0&&(c.computeVertexNormals(),c.attributes.normal.needsUpdate=!0),Array.isArray(t.normals)){const f=new Float32Array(t.normals);c.setAttribute("normal",new a.BufferAttribute(f,3))}return t.faces.length>0&&c.setIndex(t.faces),c}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e();te(n,c)}return r(),d.watch(()=>t.vertices,c=>{r()},{deep:!0}),d.watch(()=>t.faces,c=>{r()},{deep:!0}),s({three:n}),{props:t,makeGeometry:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),Ms={name:"CircleGeometry",render:()=>null},$t=d.defineComponent({...Ms,props:{name:{default:""},radius:{default:1},segments:{default:32},thetaStart:{default:0},thetaLength:{default:2*Math.PI}},setup(l,{expose:s}){const t=l;function e(c,u,f,p){return new a.CircleGeometry(c,u,f,p)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.radius,t.segments,t.thetaStart,t.thetaLength);te(n,c)}return r(),b(t,"radius",r),b(t,"segments",r),b(t,"thetaStart",r),b(t,"thetaLength",r),s({three:n}),{props:t,makeCircle:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),bs={name:"ConeGeometry",render:()=>null},Zt=d.defineComponent({...bs,props:{name:{default:""},radius:{default:1},height:{default:1},radialSegments:{default:32},heightSegments:{default:1},openEnded:{type:Boolean,default:!1},thetaStart:{default:0},thetaLength:{default:2*Math.PI}},setup(l,{expose:s}){const t=l;function e(c,u,f,p,m,h,w){return new a.ConeGeometry(c,u,f,p,m,h,w)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.radius,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength);te(n,c)}return r(),b(t,"radius",r),b(t,"height",r),b(t,"radialSegments",r),b(t,"heightSegments",r),b(t,"openEnded",r),b(t,"thetaStart",r),b(t,"thetaLength",r),s({three:n}),{props:t,makeCone:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),_s={name:"CylinderGeometry",render:()=>null},Kt=d.defineComponent({..._s,props:{name:{default:""},radiusTop:{default:1},radiusBottom:{default:1},height:{default:1},radialSegments:{default:32},heightSegments:{default:1},openEnded:{type:Boolean,default:!1},thetaStart:{default:0},thetaLength:{default:2*Math.PI}},setup(l,{expose:s}){const t=l;function e(c,u,f,p,m,h,w,_){return new a.CylinderGeometry(c,u,f,p,m,h,w,_)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.radiusTop,t.radiusBottom,t.height,t.radialSegments,t.heightSegments,t.openEnded,t.thetaStart,t.thetaLength);te(n,c)}return r(),b(t,"radiusTop",r),b(t,"radiusBottom",r),b(t,"height",r),b(t,"radialSegments",r),b(t,"heightSegments",r),b(t,"openEnded",r),b(t,"thetaStart",r),b(t,"thetaLength",r),s({three:n}),{props:t,makeCylinder:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),Es={name:"EdgesGeometry",render:()=>null},Qt=d.defineComponent({...Es,props:{geometry:null},setup(l,{expose:s}){const t=l,e=d.reactive(new a.BufferGeometry),n=d.inject("mesh",null);n&&(n.geometry=e);const i=d.inject("getGeometry"),o=d.inject("addGeometry");o(e);function r(){const f=new a.EdgesGeometry(i(t.geometry));te(e,f);const p=n;"isLine"in p&&p.computeLineDistances()}let c=d.watch(i(t.geometry),()=>{r()},{deep:!0,immediate:!0});b(t,"geometry",()=>{c(),c=d.watch(i(t.geometry),()=>{r()},{immediate:!0,deep:!0})});const u=()=>{i(t.geometry)===void 0?d.nextTick(()=>u):r()};return d.nextTick(()=>u),s({three:e}),{props:t,three:e,mesh:n,getGeometry:i,addGeometry:o,redoGeometry:r,get unwatch(){return c},set unwatch(f){c=f},waitUntilGeometryChanged:u}}});class Ne extends a.BufferGeometry{constructor(s=(n,i,o)=>o.set(n,i,Math.cos(n)*Math.sin(i)),t=8,e=8){super(),this.type="ParametricGeometry",this.parameters={func:s,slices:t,stacks:e};const n=[],i=[],o=[],r=[],c=1e-5,u=new a.Vector3,f=new a.Vector3,p=new a.Vector3,m=new a.Vector3,h=new a.Vector3;s.length<3&&console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");const w=t+1;for(let _=0;_<=e;_++){const E=_/e;for(let y=0;y<=t;y++){const S=y/t;s(S,E,f),i.push(f.x,f.y,f.z),S-c>=0?(s(S-c,E,p),m.subVectors(f,p)):(s(S+c,E,p),m.subVectors(p,f)),E-c>=0?(s(S,E-c,p),h.subVectors(f,p)):(s(S,E+c,p),h.subVectors(p,f)),u.crossVectors(m,h).normalize(),o.push(u.x,u.y,u.z),r.push(S,E)}}for(let _=0;_<e;_++)for(let E=0;E<t;E++){const y=_*w+E,S=_*w+E+1,T=(_+1)*w+E+1,A=(_+1)*w+E;n.push(y,S,A),n.push(S,T,A)}this.setIndex(n),this.setAttribute("position",new a.Float32BufferAttribute(i,3)),this.setAttribute("normal",new a.Float32BufferAttribute(o,3)),this.setAttribute("uv",new a.Float32BufferAttribute(r,2))}}const be={klein:function(l,s,t){s*=Math.PI,l*=2*Math.PI,s=s*2;let e,n;s<Math.PI?(e=3*Math.cos(s)*(1+Math.sin(s))+2*(1-Math.cos(s)/2)*Math.cos(s)*Math.cos(l),n=-8*Math.sin(s)-2*(1-Math.cos(s)/2)*Math.sin(s)*Math.cos(l)):(e=3*Math.cos(s)*(1+Math.sin(s))+2*(1-Math.cos(s)/2)*Math.cos(l+Math.PI),n=-8*Math.sin(s));const i=-2*(1-Math.cos(s)/2)*Math.sin(l);t.set(e,i,n)},plane:function(l,s){return function(t,e,n){const i=t*l,o=0,r=e*s;n.set(i,o,r)}},mobius:function(l,s,t){l=l-.5;const e=2*Math.PI*s,n=2,i=Math.cos(e)*(n+l*Math.cos(e/2)),o=Math.sin(e)*(n+l*Math.cos(e/2)),r=l*Math.sin(e/2);t.set(i,o,r)},mobius3d:function(l,s,t){l*=Math.PI,s*=2*Math.PI,l=l*2;const e=l/2,n=2.25,i=.125,o=.65;let r=i*Math.cos(s)*Math.cos(e)-o*Math.sin(s)*Math.sin(e);const c=i*Math.cos(s)*Math.sin(e)+o*Math.sin(s)*Math.cos(e),u=(n+r)*Math.sin(l);r=(n+r)*Math.cos(l),t.set(r,u,c)}};be.TubeGeometry=class extends Ne{constructor(s,t=64,e=1,n=8,i=!1){const o=t+1,r=s.computeFrenetFrames(t,i),c=r.tangents,u=r.normals,f=r.binormals,p=new a.Vector3;function m(h,w,_){w*=2*Math.PI;const E=Math.floor(h*(o-1));s.getPointAt(h,p);const y=u[E],S=f[E],T=-e*Math.cos(w),A=e*Math.sin(w);p.x+=T*y.x+A*S.x,p.y+=T*y.y+A*S.y,p.z+=T*y.z+A*S.z,_.copy(p)}super(m,t,n),this.tangents=c,this.normals=u,this.binormals=f,this.path=s,this.segments=t,this.radius=e,this.segmentsRadius=n,this.closed=i}},be.TorusKnotGeometry=class extends be.TubeGeometry{constructor(s=200,t=40,e=64,n=8,i=2,o=3){class r extends a.Curve{getPoint(m,h=new a.Vector3){const w=h;m*=Math.PI*2;const _=.5,E=(1+_*Math.cos(o*m))*Math.cos(i*m),y=(1+_*Math.cos(o*m))*Math.sin(i*m),S=_*Math.sin(o*m);return w.set(E,y,S).multiplyScalar(s)}}const c=e,u=n,f=new r;super(f,c,t,u,!0,!1),this.radius=s,this.tube=t,this.segmentsT=e,this.segmentsR=n,this.p=i,this.q=o}},be.SphereGeometry=class extends Ne{constructor(s,t,e){function n(i,o,r){i*=Math.PI,o*=2*Math.PI;const c=s*Math.sin(i)*Math.cos(o),u=s*Math.sin(i)*Math.sin(o),f=s*Math.cos(i);r.set(c,u,f)}super(n,t,e)}},be.PlaneGeometry=class extends Ne{constructor(s,t,e,n){function i(o,r,c){const u=o*s,f=0,p=r*t;c.set(u,f,p)}super(i,e,n)}};const Ss={name:"Parametriceometry",render:()=>null},qt=d.defineComponent({...Ss,props:{name:{default:""},function:{type:Function,default:be.klein},slices:{default:8},stacks:{default:8}},setup(l,{expose:s}){const t=l;function e(c,u,f){return new Ne(c,u,f)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.function,t.slices,t.stacks);te(n,c)}return r(),b(t,"function",r),b(t,"stacks",r),b(t,"slices",r),s({three:n}),{props:t,makePlane:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),Ts={name:"PlaneGeometry",render:()=>null},Wt=d.defineComponent({...Ts,props:{name:{default:""},width:{default:1},height:{default:1},widthSegments:{default:1},heightSegments:{default:1}},setup(l,{expose:s}){const t=l;function e(c,u,f,p){return new a.PlaneGeometry(c,u,f,p)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.width,t.height,t.widthSegments,t.heightSegments);te(n,c)}return r(),b(t,"width",r),b(t,"height",r),b(t,"widthSegments",r),b(t,"heightSegments",r),s({three:n}),{props:t,makePlane:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),xs={name:"RingGeometry",render:()=>null},Jt=d.defineComponent({...xs,props:{name:{default:""},innerRadius:{default:.5},outerRadius:{default:1},thetaSegments:{default:32},phiSegments:{default:1},thetaStart:{default:0},thetaLength:{default:2*Math.PI}},setup(l,{expose:s}){const t=l;function e(c,u,f,p,m,h){return new a.RingGeometry(c,u,f,p,m,h)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.innerRadius,t.outerRadius,t.thetaSegments,t.phiSegments,t.thetaStart,t.thetaLength);te(n,c)}return r(),b(t,"innerRadius",r),b(t,"outerRadius",r),b(t,"thetaSegments",r),b(t,"phiSegments",r),b(t,"thetaStart",r),b(t,"thetaLength",r),s({three:n}),{props:t,makeRing:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),As={name:"SphereGeometry",render:()=>null},en=d.defineComponent({...As,props:{name:{default:""},radius:{default:1},widthSegments:{default:32},heightSegments:{default:16},phiStart:{default:0},phiLength:{default:2*Math.PI},thetaStart:{default:0},thetaLength:{default:Math.PI}},setup(l,{expose:s}){const t=l;function e(c,u,f,p,m,h,w){return new a.SphereGeometry(c,u,f,p,m,h,w)}const n=d.reactive(new a.BufferGeometry);n.name=t.name;const i=d.inject("mesh",null);i&&(i.geometry=n);const o=d.inject("addGeometry");o(n);function r(){const c=e(t.radius,t.widthSegments,t.heightSegments,t.phiStart,t.phiLength,t.thetaStart,t.thetaLength);te(n,c)}return r(),b(t,"radius",r),b(t,"widthSegments",r),b(t,"heightSegments",r),b(t,"phiStart",r),b(t,"phiLength",r),b(t,"thetaStart",r),b(t,"thetaLength",r),s({three:n}),{props:t,makeSphere:e,three:n,mesh:i,addGeometry:o,redoGeometry:r}}}),Ls={name:"WireframeGeometry",render:()=>null},tn=d.defineComponent({...Ls,props:{geometry:null},setup(l,{expose:s}){const t=l,e=d.reactive(new a.BufferGeometry),n=d.inject("mesh",null);n&&(n.geometry=e);const i=d.inject("getGeometry"),o=d.inject("addGeometry");o(e);function r(){const f=new a.WireframeGeometry(i(t.geometry));te(e,f);const p=n;"isLine"in p&&p.computeLineDistances()}let c=d.watch(i(t.geometry),()=>{r()},{deep:!0,immediate:!0});b(t,"geometry",()=>{c(),c=d.watch(i(t.geometry),()=>{r()},{immediate:!0,deep:!0})});const u=()=>{i(t.geometry)===void 0?d.nextTick(()=>u):r()};return d.nextTick(()=>u),s({three:e}),{props:t,three:e,mesh:n,getGeometry:i,addGeometry:o,redoGeometry:r,get unwatch(){return c},set unwatch(f){c=f},waitUntilGeometryChanged:u}}}),Ps={name:"LineBasicMaterial",render:()=>null},nn=d.defineComponent({...Ps,props:{color:{default:16777215},name:{default:""},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.LineBasicMaterial({color:t.color});e.name=t.name;const n=d.inject("addMaterial");n(e);const i=d.inject("mesh",null);i&&(i.material=e);function o(){t.color&&(e.color=new a.Color(t.color)),e.opacity=t.opacity,e.transparent=t.transparent,e.needsUpdate=!0}return o(),b(t,"color",o),b(t,"opacity",o),b(t,"transparent",o),d.provide("material",e),s({three:e}),{props:t,three:e,addMaterial:n,mesh:i,applyProps:o}}}),Rs={name:"LineDashedMaterial",render:()=>null},sn=d.defineComponent({...Rs,props:{color:{default:16777215},scale:{default:1},dashSize:{default:3},gapSize:{default:1},name:{default:""},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.LineDashedMaterial({color:t.color});e.name=t.name;const n=d.inject("addMaterial");n(e);const i=d.inject("mesh",null);i&&(i.material=e);function o(){e.color=new a.Color(t.color),e.scale=t.scale,e.dashSize=t.dashSize,e.gapSize=t.gapSize,e.opacity=t.opacity,e.transparent=t.transparent,e.needsUpdate=!0}return o(),b(t,"color",o),b(t,"scale",o),b(t,"dashSize",o),b(t,"gapSize",o),b(t,"opacity",o),b(t,"transparent",o),d.provide("material",e),s({three:e}),{props:t,three:e,addMaterial:n,mesh:i,applyProps:o}}}),Cs={name:"MeshBasicMaterial"},on=d.defineComponent({...Cs,props:{color:null,side:{default:a.FrontSide},name:{default:""},opacity:{default:1},transparent:{type:Boolean,default:!1},vertexColors:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.MeshBasicMaterial;e.name=t.name,d.inject("addMaterial")(e);const i=d.inject("mesh",null);i&&(i.material=e);function o(){t.color!==void 0&&(e.color=new a.Color(t.color)),e.side=t.side,e.opacity=t.opacity,e.transparent=t.transparent,e.vertexColors=t.vertexColors,e.needsUpdate=!0}return o(),d.provide("material",e),b(t,"color",o),b(t,"side",o),b(t,"opacity",o),b(t,"transparent",o),b(t,"vertexColors",o),s({three:e}),(r,c)=>d.renderSlot(r.$slots,"default")}}),Is={name:"MeshLambertMaterial"},an=d.defineComponent({...Is,props:{color:{default:16777215},name:{default:""},side:{default:a.FrontSide},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.MeshLambertMaterial;e.name=t.name,d.inject("addMaterial")(e);const i=d.inject("mesh",null);i&&(i.material=e);function o(r){r.color&&(e.color=new a.Color(r.color)),r.side&&(e.side=r.side)}return o(t),d.watch(()=>t.color,()=>o(t)),d.watch(()=>t.side,()=>o(t)),d.watch(()=>t.opacity,()=>{e.opacity=t.opacity},{immediate:!0}),d.watch(()=>t.transparent,()=>{e.transparent=t.transparent},{immediate:!0}),d.provide("material",e),s({three:e}),(r,c)=>d.renderSlot(r.$slots,"default")}}),Os={name:"PointsMaterial",render:()=>null},rn=d.defineComponent({...Os,props:{color:{default:16777215},sizeAttenuation:{type:Boolean,default:!0},name:{default:""},size:{default:1},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.PointsMaterial({color:t.color,sizeAttenuation:t.sizeAttenuation,size:t.size});e.name=t.name;const n=d.inject("mesh",null),i=d.inject("addMaterial");i(e),n&&(n.material=e);function o(){e.color=new a.Color(t.color),e.size=t.size,e.sizeAttenuation=t.sizeAttenuation,e.opacity=t.opacity,e.transparent=t.transparent,e.needsUpdate=!0}return o(),b(t,"color",o),b(t,"size",o),b(t,"sizeAttenuation",o),b(t,"opacity",o),b(t,"transparent",o),d.provide("material",e),s({three:e}),{props:t,three:e,mesh:n,addMaterial:i,applyProps:o}}}),vs={name:"MeshNormalMaterial"},cn=d.defineComponent({...vs,props:{side:{default:a.FrontSide},name:{default:""},opacity:{default:1},transparent:{type:Boolean,default:!1}},setup(l,{expose:s}){const t=l,e=new a.MeshNormalMaterial;e.name=t.name,d.inject("addMaterial")(e);const i=d.inject("mesh",null);return i&&(i.material=e),d.watch(()=>t.side,()=>{e.side=t.side},{immediate:!0}),d.watch(()=>t.opacity,()=>{e.opacity=t.opacity},{immediate:!0}),d.watch(()=>t.transparent,()=>{e.transparent=t.transparent},{immediate:!0}),d.provide("material",e),s({three:e}),(o,r)=>d.renderSlot(o.$slots,"default")}}),Gs={name:"AmbientLight",render:()=>null},ln=d.defineComponent({...Gs,props:{color:{default:16777215},intensity:{default:1}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.AmbientLight;e.add(n);function i(o){n.color=new a.Color(o.color),n.intensity=o.intensity}return i(t),d.watch(()=>t.color,()=>i(t)),d.watch(()=>t.intensity,()=>i(t)),s({three:n}),{props:t,scene:e,three:n,applyProps:i}}}),js={name:"PointLight",render:()=>null},un=d.defineComponent({...js,props:{castShadow:{type:Boolean,default:!1},color:{default:16777215},intensity:{default:1},position:{default:()=>[0,0,0]},rotation:{default:()=>[0,0,0]},scale:{default:()=>[1,1,1]}},setup(l,{expose:s}){const t=l,e=d.inject("scene"),n=new a.PointLight;e.add(n),C(t,"position",n),C(t,"rotation",n),C(t,"scale",n);function i(o){n.color=new a.Color(o.color),n.intensity=o.intensity,n.castShadow=o.castShadow}return i(t),d.watch(()=>t.color,()=>i(t)),d.watch(()=>t.intensity,()=>i(t)),d.watch(()=>t.castShadow,()=>i(t)),s({three:n}),{props:t,scene:e,three:n,applyProps:i}}}),Ns={name:"TextureLoader",render:()=>null},dn=d.defineComponent({...Ns,props:{offset:{default:()=>[0,0]},repeat:{default:()=>[1,1]},rotation:{default:0},url:null,wrapS:{default:a.ClampToEdgeWrapping},wrapT:{default:a.ClampToEdgeWrapping}},setup(l,{expose:s}){const t=l,e=d.inject("material"),n=d.ref(new a.Texture);function i(){new a.TextureLoader().loadAsync(t.url).then(r=>{n.value=r,it(t,"offset",n.value),it(t,"repeat",n.value),"map"in e&&(e.map=n.value,e.needsUpdate=!0),o()})}function o(){n.value.wrapS=t.wrapS,n.value.wrapT=t.wrapT,n.value.rotation=t.rotation,n.value.needsUpdate=!0}return i(),b(t,"url",i),b(t,"wrapS",o),b(t,"wrapT",o),b(t,"rotation",o),s({three:n}),{props:t,material:e,three:n,load:i,applyProps:o}}});function Ds(l){l.component("Renderer",rt),l.component("Scene",ct),l.component("PerspectiveCamera",lt),l.component("OrthographicCamera",ut),l.component("OrbitControls",ft),l.component("TrackballControls",mt),l.component("TransformControls",Et),l.component("Group",St),l.component("InstancedMesh",Tt),l.component("Line",xt),l.component("LineLoop",At),l.component("LineSegments",Lt),l.component("Mesh",Pt),l.component("Points",Rt),l.component("GLTFLoader",Ft),l.component("OBJLoader",Vt),l.component("AxesHelper",zt),l.component("BoxGeometry",Xt),l.component("BufferGeometry",Yt),l.component("CircleGeometry",$t),l.component("ConeGeometry",Zt),l.component("CylinderGeometry",Kt),l.component("EdgesGeometry",Qt),l.component("ParametricGeometry",qt),l.component("PlaneGeometry",Wt),l.component("RingGeometry",Jt),l.component("SphereGeometry",en),l.component("WireframeGeometry",tn),l.component("LineBasicMaterial",nn),l.component("LineDashedMaterial",sn),l.component("MeshBasicMaterial",on),l.component("MeshLambertMaterial",an),l.component("PointsMaterial",rn),l.component("MeshNormalMaterial",cn),l.component("AmbientLight",ln),l.component("PointLight",un),l.component("TextureLoader",dn)}P.AmbientLight=ln,P.AxesHelper=zt,P.BoxGeometry=Xt,P.BufferGeometry=Yt,P.CircleGeometry=$t,P.ConeGeometry=Zt,P.CylinderGeometry=Kt,P.EdgesGeometry=Qt,P.GLTFLoader=Ft,P.Group=St,P.InstancedMesh=Tt,P.Line=xt,P.LineBasicMaterial=nn,P.LineDashedMaterial=sn,P.LineLoop=At,P.LineSegments=Lt,P.Mesh=Pt,P.MeshBasicMaterial=on,P.MeshLambertMaterial=an,P.MeshNormalMaterial=cn,P.OBJLoader=Vt,P.OrbitControls=ft,P.OrthographicCamera=ut,P.ParametricGeometry=qt,P.PerspectiveCamera=lt,P.PlaneGeometry=Wt,P.PointLight=un,P.Points=Rt,P.PointsMaterial=rn,P.Renderer=rt,P.RingGeometry=Jt,P.Scene=ct,P.SphereGeometry=en,P.TextureLoader=dn,P.TrackballControls=mt,P.TransformControls=Et,P.WireframeGeometry=tn,P.install=Ds,Object.defineProperty(P,Symbol.toStringTag,{value:"Module"})});
